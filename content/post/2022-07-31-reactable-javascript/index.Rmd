---
title: A few useful JavaScript aggregation and formatting functions for {reactable}
subtitle: Series on runtime-free content delivery
author: R package build
date: '2022-07-31'
slug: reactable-javascript
categories: []
tags: ['rstats', 'javascript']
summary: ''
authors: []
lastmod: '2022-07-31T09:20:22-05:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

**__In Progress__**

In my [last post](https://www.zajichekstats.com/post/filterable-maps/) we demonstrated how to build a filterable map widget into an HTML output that was free of `R` runtime dependency. In continuation of that theme, this article focuses on the [`reactable`](https://glin.github.io/reactable/) package, which enables you to embed interactive data tables into your document. Specifically, we'll look at how we can use its built-in JavaScript interface to define custom functions for commonly-desired aggregation and formatting. 

# Table of Contents

1. [The Basics](#thebasics)
  * [Make a summary dataset](#summarydata)
  * [The default table](#defaulttable)
  * [Built-in aggregation](#builtinaggregation)
2. [Using the JavaScript Interface](#jsinterface)
  * [Function 1: Weighted mean](#function1)

# The Basics

Let's start with loading some packages.

```{r}
require(reactable)
require(tidyverse)
```

## Make a summary dataset {#summarydata}

First we'll need to create a data frame with group-level summary statistics that we want to display. For this example, we'll look at the 30-day hospital readmission rate for heart failure patients at the top five (5) most voluminous hospitals in a handful of Midwest states.

```{r}
# Import dataset
readmission_rates <-
  read_csv(
    file = "https://data.cms.gov/provider-data/sites/default/files/resources/37e3c1486ad47b7a0eb471ecf3f7e428_1657310806/Unplanned_Hospital_Visits-Hospital.csv",
    na = c("", " ", "NA", "N/A", "Not Available")
  ) %>%
  
  # Filter to states with non-null values
  filter(
    State %in% c("WI", "MN", "MI", "IL"),
    `Measure ID` == "READM_30_HF",
    !is.na(Denominator),
    !is.na(Score)
  ) %>%
  
  # Convert to proportion
  mutate(
    Score = Score / 100
  ) %>%
  
  # Keep a few columns
  select(
    State,
    Hospital = `Facility Name`,
    Cases = Denominator,
    `30-Day Readmission Rate` = Score
  ) %>%
  
  # For each state, keep the top 5 most voluminous hospitals
  group_by(State) %>%
  slice_max(
    n = 5,
    order_by = Cases,
    with_ties = FALSE
  ) %>%
  ungroup()
readmission_rates
```

## The default table {#defaulttable}

As a starting point, let's see what we get when we call the `reactable` function without any additional arguments.

```{r}
readmission_rates %>% reactable()
```

We get about what we'd expect: a basic, paginated table where each row from our dataset is represented verbatim. There are many things we could clean up here such as rounding, number representations, formatting, and, of course, aggregating the statistics to get state-specific readmission rates.

## Built-in aggregation {#builtinaggregation}

There are a number of [built-in aggregation functions](#https://glin.github.io/reactable/articles/examples.html#grouping-and-aggregation) available to us by default. We just need to specify:

1. The groups we want the aggregation applied within using the `groupBy` argument
2. The columns we want to aggregate, and how, using `colDef` within the `columns` argument

Let's add functionality to the table above to aggregate the _total_ case count and the _average_ 30-day readmission rate within each state.

```{r}
readmission_rates %>%
  reactable(
    groupBy = "State",
    columns = 
      list(
        Cases = colDef(aggregate = "sum"),
        `30-Day Readmission Rate` = colDef(aggregate = "mean")
      )
  )
```

The problem with this table is that the displayed state-level readmission rates represent the _averaged_ rates across the individual hospitals. What we really want in the aggregation is for the hospital-specific rates to be weighted by their respective case volumes so that the state-level readmission rates are correct. This is where JavaScript comes in.

# Using the JavaScript Interface {#jsinterface}

During the call to `reactable`, our table is accessible through a JavaScript interface which makes it easy for us to customize the aggregation and formatting behavior when the default options won't suffice. We can use the `JS` function from the [`htmlwidgets`](https://www.htmlwidgets.org/) package to:

1. Define a JavaScript function as a text string
2. Supply that function as an argument in the `colDef` applicable to the function's context

## Function 1: Weighted mean {#function1}

Referring back to our [example](#builtinaggregation), we want to average the 30-day readmission rates over the hospitals within each state, but we need to weight them by their respective case volume. To do this, we can supply a custom JavaScript function to the `aggregate` argument. This function takes the entire vector of values within the group as its argument, as well as the group's rows, and returns a scalar value. We can specify the column containing the case weights directly by name within the row.

```{r}
weighted_mean <-
  function(weight) {
    JS(
      paste0(
        "function(values, rows) {
          var numerator = 0
          var denominator = 0
    
          rows.forEach(function(row, index) {
            numerator += row['", weight, "'] * values[index]
            denominator += row['", weight, "']
          })
    
          return numerator / denominator
  
        }"
      )
    )
  }
```

In our implementation, we encoded the `JS` function into an `R` function that calls for the weight column name, which generalizes its usage to any `reactable` in which we want this functionality applied.

```{r}
readmission_rates %>%
  reactable(
    groupBy = "State",
    columns = 
      list(
        Cases = colDef(aggregate = "sum"),
        `30-Day Readmission Rate` = colDef(aggregate = weighted_mean("Cases"))
      )
  )
```

