---
title: A few useful JavaScript aggregation and formatting functions for {reactable}
subtitle: Series on runtime-free content delivery
author: R package build
date: '2022-07-31'
slug: reactable-javascript
categories: []
tags: ['rstats', 'javascript']
summary: ''
authors: []
lastmod: '2022-07-31T09:20:22-05:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

**__In Progress__**

In my [last post](https://www.zajichekstats.com/post/filterable-maps/) we demonstrated how to build a filterable map widget into an HTML output that was free of `R` runtime dependency. In continuation of that theme, this article focuses on the [`reactable`](https://glin.github.io/reactable/) package, which enables you to embed interactive data tables into your output. Specifically, we'll look at how we can use its built-in JavaScript interface to define custom functions for commonly-desired aggregation and formatting. 

# Table of Contents

* [The Basics](#thebasics)
  1. [Make a summary dataset](#summarydata)
  2. [The default table](#defaulttable)

# The Basics

Let's start with loading the packages we'll use.

```{r}
require(reactable)
require(tidyverse)
```

## Make a summary dataset {#summarydata}

First we'll need to create a data frame with group-level summary statistics that we want to display. For this example, we'll look at the 30-day hospital readmission rate for heart failure patients at the top five (5) most voluminous hospitals in a handful of Midwest states.

```{r}
# Import dataset
readmission_rates <-
  read_csv(
    file = "https://data.cms.gov/provider-data/sites/default/files/resources/37e3c1486ad47b7a0eb471ecf3f7e428_1657310806/Unplanned_Hospital_Visits-Hospital.csv",
    na = c("", " ", "NA", "N/A", "Not Available")
  ) %>%
  
  # Filter to states with non-null values
  filter(
    State %in% c("WI", "MN", "MI", "IL"),
    `Measure ID` == "READM_30_HF",
    !is.na(Denominator),
    !is.na(Score)
  ) %>%
  
  # Convert to proportion
  mutate(
    Score = Score / 100
  ) %>%
  
  # Keep a few columns
  select(
    State,
    Hospital = `Facility Name`,
    Cases = Denominator,
    `30-Day Readmission Rate` = Score
  ) %>%
  
  # For each state, keep the top 5 most voluminous hospitals
  group_by(State) %>%
  slice_max(
    n = 5,
    order_by = Cases,
    with_ties = FALSE
  ) %>%
  ungroup()
readmission_rates
```

## The default table {#defaulttable}

As a starting point, let's see what we get when we call the `reactable` function without any additional arguments.

```{r}
readmission_rates %>% reactable()
```

We get about what we'd expect: a basic, paginated table where each row from our dataset is represented verbatim. There are a number of things to clean up here such as rounding, number representations, and, of course, aggregating the statistics to get state-specific readmission rates.

## Built in aggregation

There are a number of [built-in aggregation functions](#https://glin.github.io/reactable/articles/examples.html#grouping-and-aggregation) in the package. We just need to specify:

1. The groups we want with the `groupBy` argument
2. The columns to aggregate by specifying column definitions using `colDef` within the `columns` argument

Let's add functionality to the table above to aggregate the _total_ patient count and the _average_ of the remaining variables over the chest pain categories within each sex group:

```{r}
readmission_rates %>%
  reactable(
    groupBy = "State",
    columns = 
      list(
        Cases = colDef(aggregate = "sum"),
        `30-Day Readmission Rate` = colDef(aggregate = "mean")
      )
  )
```

The problem with this table is that the displayed state-specific readmission rates represent the _averaged_ rates across the individual hospitals. What we really want in the aggregation is for the hospital-specific values to be weighted by the respective case volume so that the state-specific group rates are correct. This is where JavaScript comes in.

# Custom JavaScript Functions

Our table is accessible through a JavaScript interface which makes it easy for us to customize the aggregation behavior when the default options won't suffice. We can use the `JS` function from the `htmlwidgets` package to:

1. Define a JavaScript function as a text string
2. Supply that function as the `aggregate` argument within `colDef` in our column definition list.

## Defining the function

```{r}
weighted_mean <-
  function(weight) {
    JS(
      paste0(
        "function(values, rows) {
          var numerator = 0
          var denominator = 0
    
          rows.forEach(function(row, index) {
            numerator += row['", weight, "'] * values[index]
            denominator += row['", weight, "']
          })
    
          return numerator / denominator
  
        }"
      )
    )
  }

readmission_rates %>%
  reactable(
    groupBy = "State",
    columns = 
      list(
        Cases = colDef(aggregate = "sum"),
        `30-Day Readmission Rate` = colDef(aggregate = weighted_mean("Cases"))
      )
  )
```

