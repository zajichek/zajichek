{
  "hash": "a033f1b770ed86762138438c5421e882",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Exploring COM Poisson regression\"\ndescription: \"A method for underdispersed count data\"\nauthor: \"Alex Zajichek\"\ndate: \"12/28/2021\"\nimage: \"feature.png\"\ncategories:\n  - Regression\nformat:\n  html:\n    code-fold: true\n    code-tools: true\n---\n\n\n\nA few years ago I encountered an interesting count distribution during a modeling project. The goal was to model the number of [suture anchors](https://www.shoulderdoc.co.uk/article/538) used in rotator-cuff tendon tears, and how that was influenced by tear characteristics and surgeon preference. My instinct was to fit a [Poisson](https://en.wikipedia.org/wiki/Poisson_distribution) model, but the target took on relatively small values and was also non-zero, so I had to do some digging for an alternative approach. I came across a method called Conway-Maxwell (COM) Poisson regression, which not only allowed for _overdispersion_ (i.e., the population variance is greater than its mean), but also _underdispersion_. It hit me that I had never come across methodology for the latter and it seemed to align with my problem, so I was intrigued (Full Disclosure: I heard of COM-Poisson prior to that, albeit knew nothing about it, when one of my super smart graduate school buddies was doing research on it, so that's also why it stuck). \n\nLong story short, we didn't end up using the COM-Poisson model for the [anchor project](https://www.jshoulderelbow.org/article/S1058-2746(18)30555-X/fulltext) 😁, and instead went in favor of [Zero-Truncated Poisson regression](https://stats.oarc.ucla.edu/r/dae/zero-truncated-poisson/). Nevertheless I thought it was an awesome method that warranted further exploration and later did a [talk](NonTraditionalCountRegression.pdf) on it. That was a few years ago--so this article is intended to be a reworking of that talk to relearn it for myself, but also to get the word out about this awesome method! All code is written in R.\n\n# Table Of Contents\n\n* [A Review of Poisson Regression](#reviewofpoisson)\n  + [The Poisson Distribution](#poissondistribution)\n  + [Model Formulation](#modelformulation)\n* [Conway-Maxwell (COM) Poisson Regression](#compoisson)\n  + [The COM-Poisson Distribution](#compoissondistribution)\n  + [The Regression Model](#compoissonregressionmodel)\n  + [Testing for Violations of Equidispersion](#compoissonlrt)\n  + [Stratified Dispersion](#stratifieddispersion)\n  + [Generating Fitted Values](#comfittedvalues)\n  + [Simulation: Power of Equidispersion Test](#compowersim)\n* [Conclusion](#conclusion)\n* [Code Appendix](#codeappendix)\n\n# A Review of Poisson Regression {#reviewofpoisson}\n\nI really like making up examples, so lets start with that:\n\nSuppose hospital administrators are interested in emergency department (ED) utilization and have asked a few questions:\n\n1. How many patients can we expect to see in a given day?\n2. What is the likelihood that we see more than 40 patients in a single day?\n3. Do we see more variation during the week versus weekend, or in the AM versus PM hours?\n\nTo expedite the process, we're given a pre-built dataset called `ed_volumes` containing the number of patients entering the ED each (half) day over the past calendar year.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nrequire(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: tidyverse\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\n# Set a seed\nset.seed(123)\n\n### 1. Create simulated dataset\n\n# Generating a random Poisson parameter\ned_true_mean <-\n  runif(\n    n = 1,\n    min = 12.5,\n    max = 25\n  )\n\n# Build the dataset\ned_volumes <-\n  tibble(\n    Date = rep(as.Date(\"2021-12-31\") - seq(0, 364, 1), 2),\n    TimeOfDay = c(rep(\"AM\", length(Date) / 2), rep(\"PM\", length(Date) / 2)),\n    Volume = \n      rpois(\n        n = length(Date), \n        lambda = ifelse(weekdays(Date) %in% c(\"Saturday\", \"Sunday\"), ed_true_mean - 5, ed_true_mean)\n      )\n  ) %>%\n  arrange(\n    desc(Date),\n    TimeOfDay\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load some packages\nrequire(tidyverse)\n\n# Check the dataset\nprint(ed_volumes, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 730 × 3\n  Date       TimeOfDay Volume\n  <date>     <chr>      <int>\n1 2021-12-31 AM            19\n2 2021-12-31 PM            12\n3 2021-12-30 AM            20\n4 2021-12-30 PM            20\n5 2021-12-29 AM             9\n# ℹ 725 more rows\n```\n\n\n:::\n:::\n\n\n\nFirst, let's take a look at the distribution of total daily patient volume over the time period:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ned_volumes %>%\n  \n  # For each date\n  group_by(Date) %>%\n  \n  # Compute the total \n  summarise(\n    Volume = sum(Volume),\n    .groups = \"drop\"\n  ) %>%\n  \n  # Make a plot\n  ggplot() +\n  geom_histogram(\n    aes(\n      x = Volume\n    ),\n    fill = \"gray\",\n    color = \"black\",\n    bins = 30\n  ) +\n  geom_vline(\n    aes(\n      xintercept = mean(Volume)\n    ),\n    color = \"#b84f48\"\n  ) +\n  geom_text(\n    aes(\n      x = mean(Volume) + 1,\n      y = 41,\n      label = str_c(\"Avg: \", round(mean(Volume), 1), \" patients\")\n    ),\n    color = \"#b84f48\",\n    hjust = -.15\n  ) +\n  xlab(\"Daily Patient Volume\") +\n  ylab(\"Frequency\") +\n  theme(\n    legend.position = \"none\",\n    axis.title = element_text(size = 14),\n    axis.text = element_text(size = 12),\n    strip.text = element_text(size = 12),\n    panel.background = element_blank(),\n    panel.grid.major.y = element_line(color = \"gray\")\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_text(aes(x = mean(Volume) + 1, y = 41, label = str_c(\"Avg: \", : All aesthetics have length 1, but the data has 365 rows.\nℹ Please consider using `annotate()` or provide this layer with data containing\n  a single row.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\nThere were 29.5 patients per day on average, ranging from 11 to 47. Knowing that this is a count distribution, we think to use a Poisson model to provide our estimates for the first two questions. Let's remind ourselves of the specifics:\n\n## The Poisson Distribution {#poissondistribution}\n\nIf the probability mass function (PMF) for a non-negative, integer-valued $Y$ is:\n\n$$P(Y = y|\\lambda) = \\frac{e^{-\\lambda}\\lambda^y}{y!}$$\nthen $Y$ is distributed as a Poisson random variable, and has the following property:\n\n$$E[Y] = \\lambda$$\nIt turns out that the maximum likelihood estimator (MLE) for $\\lambda$ is the [sample average](https://www.statlect.com/fundamentals-of-statistics/Poisson-distribution-maximum-likelihood). Remembering this, _we provide the estimate for the first question to be 30 patients. (rounding up)_\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlambda_hat <- mean(with(ed_volumes, tapply(Volume, Date, sum)))\nlambda_hat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 29.53699\n```\n\n\n:::\n:::\n\n\n\nWe also know that once we have an estimate for $\\lambda$ that we can compute probabilities by plugging it into the PMF:\n\n$$P(Y>40) = 1 - P(Y\\leq40) = 1 - \\sum_{y=0}^{40} \\frac{e^{-\\lambda}\\lambda^y}{y!}$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 0:40\np <- exp(-lambda_hat) * lambda_hat^y / factorial(y)\nquestion2 <- 1 - sum(p)\nquestion2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.02633629\n```\n\n\n:::\n\n```{.r .cell-code}\n# Alternative approach\n1- ppois(40, lambda_hat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.02633629\n```\n\n\n:::\n:::\n\n\n\n_We estimate that there is a 2.6% chance that we will see more than 40 patients in the ED in a single day_--done with the first two questions! \n\n😨\n\nUnfortunately, we missed a crucial assumption about the Poisson distribution that we didn't account for:\n\n$$E[Y] = Var[Y]$$\nThe estimates we provided assumed that the mean and variance of our underlying distribution were equal. The sample variance was 53.4 which is considerably larger than the mean of 29.5. Here is what an actual Poisson distribution looks like with $\\lambda$ = 29.5 (our sample average) in comparison with the observed data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ned_volumes %>%\n  \n  # Compute the total for each date\n  group_by(Date) %>%\n  summarise(\n    Volume = sum(Volume),\n    .groups = \"drop\"\n  ) %>%\n  \n  # Count the occurrences of each daily volume\n  group_by(Volume) %>%\n  summarise(\n    N = n(),\n    .groups = \"drop\"\n  ) %>%\n  \n  # Compute the observed and theoretical relative frequencies\n  mutate(\n    Observed = N / sum(N),\n    Theoretical = dpois(Volume, lambda = lambda_hat)\n  ) %>%\n  \n  # Remove raw count\n  select(-N) %>% \n  \n  # Make a plot\n  ggplot(\n    aes(\n      x = Volume\n    )\n  ) +\n  geom_col(\n    aes(\n      y = Observed,\n      fill = \"Observed Data\"\n    ),\n    color = \"black\"\n  ) +\n  geom_area(\n    aes(\n      y = Theoretical,\n      fill = \"Actual Poisson\"\n    ),\n    alpha = .25,\n    color = \"black\"\n  ) +\n  geom_vline(\n    aes(\n      xintercept = lambda_hat\n    ),\n    color = \"#b84f48\"\n  ) +\n  xlab(\"Daily Patient Volume\") +\n  ylab(\"Relative Frequency (%)\") +\n  theme(\n    legend.title = element_blank(),\n    legend.text = element_text(size = 12),\n    legend.position = \"top\",\n    axis.title = element_text(size = 14),\n    axis.text = element_text(size = 12),\n    strip.text = element_text(size = 12),\n    panel.background = element_blank(),\n    panel.grid.major.y = element_line(color = \"gray\")\n  ) +\n  scale_y_continuous(labels = scales::percent) +\n  scale_fill_manual(values = c(\"blue\", \"gray\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\nThe tails of the observed sample are heavier than a Poisson would be with the same mean. Therefore, the estimates we provided for questions 1 and 2 are probably not very accurate. Let's take a different approach: _answer question 3 first, and then work our way back to the other two._ \n\nAs a reminder, we want to assess whether there is more variation in patient volume during the week versus weekend, or in the AM versus PM hours. To get this comparison, we need a way to simultaneously estimate the effect of each of these factors on the patient volume: enter Poisson regression. \n\n## Model Formulation {#modelformulation}\n\nJust like other [generalized linear models](https://en.wikipedia.org/wiki/Generalized_linear_model) (GLM), a Poisson regression model estimates the population average (the same average as described above!), _but conditioned on a set of covariates_. \n\nMore formally, for a given set of covariates $x_1, x_2, .., x_p$, we assume the following functional form:\n\n$$log(\\lambda_i) = \\beta_0 + \\beta_1x_{i1} + \\beta_2x_{i2}+...+\\beta_px_{ip} = X_i\\beta$$\nThis _log-linear_ model allows us to estimate the mean number of events (i.e., the Poisson parameter $\\lambda$) for a given arrangement of covariate values. We also get informative interpretation of the individual effects of each covariate. For our example, the model looks like this:\n\n$$log(\\lambda_i) = \\beta_0 + \\beta_{weekend}x_{i_{weekend}} + \\beta_{PM}x_{i_{PM}}$$\nwhere $\\lambda_i$ is the expected (half-day) patient volume, $x_{i_{weekend}} = 1$ if it is Saturday or Sunday, and $x_{i_{PM}} = 1$ if it is PM hours (and they are 0 otherwise). We can take the following steps to estimate the $\\beta$ parameters:\n\n1. Plug the regression formula into the Poisson PMF\n\n$$\n\\begin{equation} \n\\begin{split}\nP(Y_i = y_i|\\lambda_i) & = \\frac{e^{-\\lambda_i}\\lambda_i^{y_i}}{y_i!} \\\\\n& = \\frac{e^{-e^{X_i\\beta}}{(e^{X_i\\beta})}^{y_i}}{y_i!} \\\\\n\\end{split}\n\\end{equation}\n$$\n\n2. Derive the likelihood function\n\n$$L(\\lambda_i) = \\prod_{i=1}^N \\frac{e^{-e^{X_i\\beta}}{(e^{X_i\\beta})}^{y_i}}{y_i!} \\\\$$\nwhere $N$ is the total number of (half) days.\n\n3. Compute the MLE's\n\n$$\\hat{\\beta} = max_{\\beta} L(\\lambda_i)\\\\$$\n$\\hat{\\beta}$ is the set of estimated parameter values computed from maximizing the likelihood function. Once we have these, we can plug them into the regression formula, and away we go! Luckily, our software will compute these for us--all we need to do is supply the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit a generalized linear model\nmodel <-\n  glm(\n    formula = Volume ~ Weekend + PM, # Specify the model form\n    data = # Supply the data\n      ed_volumes %>% \n      mutate(\n        Weekend = weekdays(Date) %in% c(\"Saturday\", \"Sunday\"),\n        PM = TimeOfDay == \"PM\"\n      ),\n    family = \"poisson\" # Indicate the likelihood\n  )\n\n# Show the model summary\nsummary(model)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm(formula = Volume ~ Weekend + PM, family = \"poisson\", data = ed_volumes %>% \n    mutate(Weekend = weekdays(Date) %in% c(\"Saturday\", \"Sunday\"), \n        PM = TimeOfDay == \"PM\"))\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept)  2.78530    0.01455 191.483   <2e-16 ***\nWeekendTRUE -0.41433    0.02371 -17.474   <2e-16 ***\nPMTRUE       0.01762    0.01926   0.915     0.36    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 1054.15  on 729  degrees of freedom\nResidual deviance:  723.55  on 727  degrees of freedom\nAIC: 4007.4\n\nNumber of Fisher Scoring iterations: 4\n```\n\n\n:::\n:::\n\n\n\nThe estimated model turns out to be:\n\n$$log(\\hat{\\lambda_i}) = 2.7853 - 0.4143x_{i_{weekend}} + 0.0176x_{i_{PM}}$$\nwhere $\\hat{\\lambda_i}$ is the _estimated_ average number of patients showing up to the ED on a given day of the week and time of day. Let's take a look at the four possible estimated means:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make grid of possible values for each input\nlist(\n  Weekend = c(TRUE, FALSE),\n  PM = c(TRUE, FALSE)\n) %>%\n  \n  # Find cross-product\n  cross_df() %>%\n  \n  # Add some columns\n  mutate(\n    \n    # Add predictions\n    EstimatedVolume =\n      predict(\n        model, # Supply the model\n        newdata = data.frame(Weekend, PM),\n        type = \"response\" # Applies the inverse link to the linear predictor\n      ),\n    EstimatedVolume = round(EstimatedVolume, 2),\n    \n    # Clean up names\n    Weekend = \n      case_when(\n        Weekend ~ \"Sat, Sun\",\n        TRUE ~ \"Mon - Fri\"\n      ) %>%\n      factor() %>%\n      fct_relevel(\"Mon - Fri\"),\n    PM = \n      case_when(\n        PM ~ \"PM\",\n        TRUE ~ \"AM\"\n      ) %>%\n      factor() %>%\n      fct_relevel(\n        \"AM\"\n      )\n  ) %>%\n  \n  # Rearrange\n  arrange(\n    Weekend,\n    PM\n  ) %>%\n  \n  # Send over the columns\n  pivot_wider(\n    names_from = PM,\n    values_from = EstimatedVolume\n  ) %>%\n  \n  # Rename column\n  rename(\n    `Day of week` = Weekend\n  ) %>%\n  \n  # Make a kable\n  knitr::kable(\n    format = \"html\",\n    caption = \"Expected ED patient volume\"\n  ) %>%\n  kableExtra::kable_styling(\n    full_width = FALSE,\n    bootstrap_options = c(\"striped\", \"responsive\")\n  ) %>%\n  kableExtra::add_header_above(c(\"\", \"Time of day\" = 2))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `cross_df()` was deprecated in purrr 1.0.0.\nℹ Please use `tidyr::expand_grid()` instead.\nℹ See <https://github.com/tidyverse/purrr/issues/768>.\n```\n\n\n:::\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-responsive\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Expected ED patient volume</caption>\n <thead>\n<tr>\n<th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"1\"></th>\n<th style=\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \" colspan=\"2\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \">Time of day</div></th>\n</tr>\n  <tr>\n   <th style=\"text-align:left;\"> Day of week </th>\n   <th style=\"text-align:right;\"> AM </th>\n   <th style=\"text-align:right;\"> PM </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Mon - Fri </td>\n   <td style=\"text-align:right;\"> 16.20 </td>\n   <td style=\"text-align:right;\"> 16.49 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Sat, Sun </td>\n   <td style=\"text-align:right;\"> 10.71 </td>\n   <td style=\"text-align:right;\"> 10.90 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\nOur model suggests that we see $1 - e^{\\beta_{weekend}} \\approx$ 33.9% _less_ patient volume on the weekends compared to during the week, regardless if it is AM or PM hours--this is reflected in our table estimates. We can also see that there is little difference in patient volume by the time of day, regardless of the day of the week. \n\n__*Answer to Question 3*__\n\nThe evidence tells us that not only is the day of the week the _more important_ factor, but the time of day does not appear to matter at all. This is clear when we stratify our observed sample distribution:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ned_volumes %>% \n  \n  # Make the indicators\n  mutate(\n    Weekend = \n      case_when(\n        weekdays(Date) %in% c(\"Saturday\", \"Sunday\") ~ \"Sat, Sun\",\n        TRUE ~ \"Mon - Fri\"\n      ) %>%\n      factor() %>%\n      fct_relevel(\"Mon - Fri\"),\n    TimeOfDay = \n      TimeOfDay %>%\n      factor() %>%\n      fct_relevel(\n        \"AM\"\n      )\n  ) %>%\n  \n  # Make a plot\n  ggplot() +\n  geom_histogram(\n    aes(\n      x = Volume,\n      fill = Weekend\n    ),\n    color = \"black\",\n    bins = 20,\n    position = \"identity\",\n    alpha = .5\n  ) + \n  facet_wrap(\n    ~TimeOfDay,\n    nrow = 2\n  ) +\n  xlab(\"Half-Day Patient Volume\") +\n  ylab(\"Frequency\") +\n  theme(\n    legend.position = \"top\",\n    legend.title = element_text(size = 12),\n    legend.text = element_text(size = 12),\n    axis.title = element_text(size = 14),\n    axis.text = element_text(size = 12),\n    strip.text = element_text(size = 12),\n    panel.background = element_blank(),\n    panel.grid.major.y = element_line(color = \"gray\")\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n__*Answers to Questions 1 & 2*__\n\nSo back to the first two questions. How can we use what we found for question 3 to inform us of these answers? Remember, we need to provide estimates regarding the _total_ daily patient volume even though our model target was half-day patient volume. We have a couple options:\n\n1. Since we have established that the time of day does not impact patient volume, we could fit a new model by first aggregating the target to reflect the total daily patient volume and then only add the weekday versus weekend factor as a covariate. \n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit a generalized linear model\nmodel2 <-\n  glm(\n    formula = Volume ~ Weekend, # Specify the model form\n    data = \n      ed_volumes %>% \n      \n      # For each date\n      group_by(Date) %>%\n      \n      # Compute the total daily patient volume\n      summarise(\n        Volume = sum(Volume),\n        .groups = \"drop\"\n      ) %>%\n      \n      # Make the indicator\n      mutate(\n        Weekend = weekdays(Date) %in% c(\"Saturday\", \"Sunday\")\n      ),\n    family = \"poisson\" # Indicate the likelihood\n  )\n\n# Show the model summary\nsummary(model2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm(formula = Volume ~ Weekend, family = \"poisson\", data = ed_volumes %>% \n    group_by(Date) %>% summarise(Volume = sum(Volume), .groups = \"drop\") %>% \n    mutate(Weekend = weekdays(Date) %in% c(\"Saturday\", \"Sunday\")))\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept)  3.48729    0.01082  322.15   <2e-16 ***\nWeekendTRUE -0.41433    0.02371  -17.47   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 681.97  on 364  degrees of freedom\nResidual deviance: 352.21  on 363  degrees of freedom\nAIC: 2252.7\n\nNumber of Fisher Scoring iterations: 4\n```\n\n\n:::\n:::\n\n\n\nNotice the relative effect of the day of week factor remained consistent from the original model--the intercept just changed to reflect the shifted distribution for the total patient volume. This approach works, but lets use the model we originally developed...\n\n2. This option requires us to know a [property](https://math.stackexchange.com/questions/221078/poisson-distribution-of-sum-of-two-random-independent-variables-x-y) of Poisson random variables. Specifically, if _X_ and _Y_ are two independent Poisson random variables and $Z = X + Y$, then\n\n$$Z \\sim Poisson(\\lambda_X + \\lambda_Y)$$\nwhere $\\lambda_X$ and $\\lambda_Y$ are the expected values (means) for _X_ and _Y_, respectively. This is relevant to us because we need to aggregate our model estimates over the time of day in order to get estimates for the total daily volume. Specifically, if $V$ is the patient volume, then $V_{Daily} = V_{AM} + V_{PM}$ for a particular day of the week. We assume from our model specification above that $V_{AM}$ and $V_{PM}$ follow independent Poisson distributions. Thus, we get the following:\n\n$$\n\\begin{equation}\n\\begin{split}\n\\lambda_{Daily} & = E[V_{Daily}] \\\\\n& = E[V_{AM} + V_{PM}] \\\\\n& = E[V_{AM}] + E[V_{PM}] \\\\\n& = \\lambda_{AM} + \\lambda_{PM} \\\\\n& = e^{\\beta_0 + \\beta_{weekend}x_{i_{weekend}}} + e^{\\beta_0 + \\beta_{weekend}x_{i_{weekend}} + \\beta_{PM}} \\\\\n& = e^{\\beta_0 + \\beta_{weekend}x_{i_{weekend}}} (1 + e^{\\beta_{PM}})\\\\\n& =\n\\begin{cases} \ne^{\\beta_0} (1 + e^{\\beta_{PM}}) & \\text{if M-F} \\\\\ne^{\\beta_0 + \\beta_{weekend}} (1 + e^{\\beta_{PM}}) & \\text{if Sat, Sun} \\\\\n\\end{cases} \\\\\n& \\approx\n\\begin{cases} \n32.70 & \\text{if M-F} \\\\\n21.61         & \\text{if Sat, Sun} \\\\\n\\end{cases}\n\\end{split}\n\\end{equation}\n$$\nSimply put, to get estimates around the total daily volume, we summed the regression equation over the time of day variable. Note that this is exactly what we would have gotten by just taking the sample mean of total daily volume stratified by each day of week grouping:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstratified_means <-\n  ed_volumes %>% \n  \n  # For each date\n  group_by(Date) %>%\n  \n  # Compute the total daily patient volume\n  summarise(\n    Volume = sum(Volume),\n    .groups = \"drop\"\n  ) %>%\n  \n  # Make the indicator\n  mutate(\n    Weekend = \n      case_when(\n        weekdays(Date) %in% c(\"Saturday\", \"Sunday\") ~ \"Sat, Sun\",\n        TRUE ~ \"Mon - Fri\"\n      ) %>%\n      factor() %>%\n      fct_relevel(\"Mon - Fri\")\n  ) %>%\n  \n  # For each group\n  group_by(Weekend) %>%\n  \n  # Compute the mean\n  summarise(\n    Mean = mean(Volume),\n    Variance = var(Volume),\n    .groups = \"drop\"\n  )\n\nstratified_means %>%\n  \n  # Make a kable\n  knitr::kable(\n    format = \"html\",\n    caption = \"Stratified Daily Sample Means and Variances\"\n  ) %>%\n  kableExtra::kable_styling(\n    full_width = FALSE,\n    bootstrap_options = c(\"striped\", \"responsive\")\n  ) \n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-responsive\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Stratified Daily Sample Means and Variances</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Weekend </th>\n   <th style=\"text-align:right;\"> Mean </th>\n   <th style=\"text-align:right;\"> Variance </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Mon - Fri </td>\n   <td style=\"text-align:right;\"> 32.69732 </td>\n   <td style=\"text-align:right;\"> 31.93495 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Sat, Sun </td>\n   <td style=\"text-align:right;\"> 21.60577 </td>\n   <td style=\"text-align:right;\"> 19.40618 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\nNotice also that the stratified sample _variances_ align much more with our assumptions in using a Poisson distribution--this was one of our [problems earlier](#poissondistribution), but it appears to be resolved! Now that we have weekday and weekend-specific Poisson distributions, we can confidently compute our final estimates for questions 1 and 2 the same way we did [above](#poissondistribution). \n\nTable 2 already shows the answer to question 1: _we can expect to see 33 patients per day Monday-Friday, and 22 patients on Saturdays or Sundays._ To get the updated estimates for question 2, we just need to plug in the new means to the PDF and compute the cumulative probability:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquestion2_updated <-\n  stratified_means %>%\n  \n  # For each set, compute the cumulative probability\n  cheese::stratiply(\n    by = Weekend,\n    f = ~1 - sum(exp(-.x$Mean) * .x$Mean^c(0:40) / factorial(c(0:40)))\n  )\nquestion2_updated\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`Mon - Fri`\n[1] 0.08959949\n\n$`Sat, Sun`\n[1] 0.0001298706\n```\n\n\n:::\n:::\n\n\n\n_We estimate that there is a 8.96% chance that we will see more than 40 patients on any given Monday-Friday, and a 0.01% chance that we will see that many patients on the weekend._\n\nOkay we got a little carried away with that but hopefully you have an idea of how Poisson regression works.\n\n# Conway-Maxwell (COM) Poisson Regression {#compoisson}\n\nNow that we have a foundation for standard Poisson regression, we can dig into COM-Poisson! We will use the [`COMPoissonReg`](https://github.com/lotze/COMPoissonReg) package in R, which can be installed from CRAN with `install.packages(\"COMPoissonReg\")`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the package\nrequire(COMPoissonReg)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: COMPoissonReg\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Rcpp\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: numDeriv\n```\n\n\n:::\n:::\n\n\n\n## The COM-Poisson Distribution {#compoissondistribution}\n\nIf the PMF for a non-negative, integer-valued $Y$ is:\n\n$$P(Y = y|\\lambda, \\nu) = \\frac{\\lambda^y}{y!^{\\nu}Z(\\lambda, \\nu)}$$\nwhere $\\lambda, \\nu > 0$, and \n\n$$Z(\\lambda, \\nu) = \\sum_{k=0}^{\\infty}\\frac{\\lambda^k}{k!^{\\nu}}$$\nthen $Y$ is distributed as a COM-Poisson random variable.\n\nThat's kind of a mouthful, but we can see some similarities in its form to the [Poisson PDF](#poissondistribution). In fact, if you're really math-savvy (which I'm not, I had to look this up), you'll notice that the function $Z$ is a _[power series](https://en.wikipedia.org/wiki/Power_series)_. When we set $\\nu = 1$, then\n\n$$Z(\\lambda, \\nu = 1) = \\sum_{k=0}^{\\infty}\\frac{\\lambda^k}{k!} = e^\\lambda$$\nPlugging that result back into the full PMF, it turns out to be _exactly_ the same as a Poisson distribution. This tells us that **_the Poisson distribution is a special case of the COM-Poisson_**. In the other words, the COM-Poisson is a generalization of the Poisson distribution, so we'll expect it do everything that the latter can--plus more.\n\n### Dispersion Parameter\n\nAn important feature of the COM-Poisson PDF is the parameter $\\nu$, which determines its _dispersion_ (i.e., how variable it is relative to its mean). In the standard Poisson distribution, the mean and variance are always the same, by definition. The $\\nu$ parameter allows us to relax that restriction in cases where it does not apply (or we don't want to force it to). The following table describes the properties when it is above, below, and equal to 1:\n\nParameter|Implies|Described As\n------|-----------|----------\n$\\nu=1$|$E[Y] = Var[Y]$|Equidispersed\n$\\nu<1$|$E[Y] < Var[Y]$|Overdispersed\n$\\nu>1$|$E[Y] > Var[Y]$|Underdispersed\n\n### Mean and Variance {#compoissonmeanapprox}\n\nUnfortunately, there is [no closed form solution](https://faculty.georgetown.edu/kfs7/MY%20PUBLICATIONS/COMPoissonModelForCountDataWithDiscussion.pdf) for the mean and variance of a COM-Poisson random variable. However, there are a couple related properties that are worth relaying:\n\n* The $\\lambda$ parameter is the mean of the power-transformed counts\n\n$$E[Y^\\nu] = \\lambda$$\n\n* The mean and variance can be approximated as:\n\n$$E[Y] \\approx \\lambda^{1/\\nu} - \\frac{\\nu-1}{2\\nu}$$\n$$Var[Y] \\approx \\frac{\\lambda^{1/\\nu}}{\\nu}$$\nwhen $\\nu \\leq 1$ (overdispersed) or $\\lambda > 10^\\nu$ (larger counts).\n\n### Centrality Simulation {#centralitysimulation}\n\nThe properties described above give us some useful information, but it is hard to make sense of how these parameters directly govern the data we might observe from a COM-Poisson distribution. To give us a bit more insight, lets randomly generate a bunch of data for different parameter combinations and see what we find. To do this, we'll use the `rcmp` function.\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make a parameter grid\nparams <-\n  list(\n    lambda = c(1, 3, 5, 10, 25, 50),\n    nu = c(.5, 1, 1.25, 1.5)\n  ) %>%\n  cross_df()\n\n# Number of samples\nn <- 500\n\n# Number of simulations\ns <- 100\n\n# Set a seed\nset.seed(123)\n\ncompoisson_sim1 <-\n  params %>%\n  \n  # Split into a list\n  split(1:nrow(.)) %>%\n  \n  # For each element\n  map_df(\n    function(.x) {\n      \n      1:s %>%\n        \n        # For each iteration\n        map_df(\n          function(.sim) {\n            \n            # Time the sampling\n            temp_time <- system.time(temp_value <- rcmp(n = n, lambda = .x$lambda, nu = .x$nu))\n            \n            tibble(\n              s = .sim,\n              lambda = .x$lambda,\n              nu = .x$nu,\n              value = temp_value,\n              time = temp_time[\"elapsed\"][[1]]\n            )\n            \n          }\n        )\n    }\n  )\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nWe took 100 random samples of size 500 from 24 parameter combinations. This process took about 94.1 seconds to run. Lets first take a quick look at the distributions from the first simulation for each parameter set.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompoisson_sim1 %>%\n  \n  # Filter to the first simulated value\n  filter(\n    s == 1\n  ) %>%\n  \n  # Convert to factors\n  mutate(\n    across(\n      c(\n        lambda,\n        nu\n      ),\n      factor\n    ),\n    lambda = \n      lambda %>%\n      fct_relabel(\n        function(x) paste0(\"lambda == \", x)\n      )\n  ) %>%\n  \n  # Make a plot\n  ggplot() +\n  geom_histogram(\n    aes(\n      x = value,\n      fill = nu\n    ),\n    position = \"identity\",\n    alpha = 0.5\n  ) +\n  facet_wrap(\n    ~lambda,\n    scales = \"free\",\n    label = \"label_parsed\"\n  ) +\n  xlab(\"Observed Value\") +\n  ylab(\"Frequency\") +\n  theme(\n    legend.position = \"top\",\n    legend.title = element_text(size = 12),\n    legend.text = element_text(size = 12),\n    axis.title = element_text(size = 14),\n    axis.text = element_text(size = 12),\n    strip.text = element_text(size = 12),\n    panel.background = element_blank(),\n    panel.grid.major.y = element_line(color = \"gray\")\n  ) +\n  labs(\n    fill = expression(nu)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nIt looks like the magnitude of counts increases with $\\lambda$, and decreases with $\\nu$. To get a more concrete view of this, lets compute the sample mean and variance for each iteration, and then average those over the simulations for each parameter combination. By doing this, we'll also get a sense of the sampling variability of these statistics when $n=$ 500.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompoisson_sim1 %>%\n  \n  # For each group\n  group_by(lambda, nu, s) %>%\n  \n  # Compute the statistics\n  summarise(\n    Mean = mean(value),\n    Variance = var(value),\n    .groups = \"drop\"\n  ) %>%\n  \n  # Send the statistics down the rows\n  pivot_longer(\n    cols = c(Mean, Variance)\n  ) %>%\n  \n  # For each group\n  group_by(lambda, nu, name) %>%\n  \n  # Compute the mean/standard error\n  summarise(\n    Mean = mean(value),\n    SE = sd(value),\n    .groups = \"drop\"\n  ) %>%\n  \n  # Join to get the average time for each iteration\n  inner_join(\n    y = \n      compoisson_sim1 %>%\n      \n      # Remove the value, get unique rows\n      select(-value) %>%\n      distinct() %>%\n      \n      # For each group\n      group_by(lambda, nu) %>%\n      \n      # Compute the average time per iteration\n      summarise(\n        time = mean(time),\n        .groups = \"drop\"\n      ),\n    by = \n      c(\n        \"lambda\",\n        \"nu\"\n      )\n  ) %>%\n  \n  # Convert to factors\n  mutate(\n    nu = \n      nu %>%\n      factor() %>%\n      fct_relabel(\n        function(x) paste0(\"nu == \", x)\n      )\n  ) %>%\n  \n  # Make a plot\n  ggplot(\n    aes(\n      x = lambda,\n      y = Mean\n    )\n  ) +\n  geom_line(\n    aes(\n      color = name\n    ),\n    size = 1.25\n  ) +\n  geom_point(\n    aes(\n      color = name\n    ),\n    size = 3\n  ) +\n  geom_ribbon(\n    aes(\n      ymin = Mean - 2*SE,\n      ymax = Mean + 2*SE,\n      fill = name\n    ),\n    alpha = .25\n  ) +\n  facet_wrap(\n    ~nu,\n    scales = \"free_y\",\n    label = \"label_parsed\"\n  ) +\n  ylab(\"Value\") +\n  theme(\n    legend.position = \"top\",\n    legend.title = element_blank(),\n    legend.text = element_text(size = 12),\n    axis.title = element_text(size = 14),\n    axis.text = element_text(size = 12),\n    strip.text = element_text(size = 12),\n    panel.background = element_blank(),\n    panel.grid.major.y = element_line(color = \"gray\")\n  ) +\n  scale_x_continuous(\n    breaks = unique(params$lambda)\n  ) +\n  labs(\n    x = expression(lambda)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\nWhen $\\nu=0.5$ (overdispersed), the counts become large quickly with an increasing $\\lambda$. As the data becomes more underdispersed ($\\nu > 1$), the variance increases at a slower rate as $\\lambda$ increases, relative to the mean.\n\nSo how does this translate to a regression model?\n\n## The Regression Model {#compoissonregressionmodel}\n\nIt turns out that the model structure for COM-Poisson regression is very similar to the [standard Poisson model](#modelformulation). In fact, we can just copy and paste it from above:\n\n$$log(\\lambda_i) = \\beta_0 + \\beta_1x_{i1} + \\beta_2x_{i2}+...+\\beta_px_{ip} = X_i\\beta$$\nThe basic structure models the $\\lambda$ parameter (on the log scale) as a linear combination of covariates. In turn, the steps for estimating the parameters are also the same:\n\n1. Plug the regression formula into the COM-Poisson PDF\n2. Derive the likelihood function\n3. Compute the maximum likelihood estimates (MLEs)\n\nThe only difference is that the $\\lambda$ parameter in this model no longer [represents the mean](#poissondistribution). So when we generate fitted values or interpret parameter estimates, there has to be a little more care taken as to what those represent. \n\nLet's take a quick look at how to fit a model with the `glm.cmp` function and orient ourselves with its output. We'll use the `ed_volumes` dataset from the [previous section](#reviewofpoisson).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompoisson_model1 <-\n  \n  # Function to fit a COM-Poisson model\n  glm.cmp(\n    formula.lambda = Volume ~ Weekend + PM, # lamda parameter linear predictor\n    data = \n      ed_volumes %>% \n      mutate(\n        Weekend = weekdays(Date) %in% c(\"Saturday\", \"Sunday\"),\n        PM = TimeOfDay == \"PM\"\n      )\n  )\n\ncompoisson_model1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCMP coefficients\n              Estimate     SE  z-value   p-value\nX:(Intercept)   2.8470 0.1531  18.5957 3.481e-77\nX:WeekendTRUE  -0.4230 0.0323 -13.1174 2.619e-39\nX:PMTRUE        0.0180 0.0195   0.9251    0.3549\nS:(Intercept)   0.0217 0.0529   0.4096    0.6821\n--\nTransformed intercept-only parameters\n   Estimate     SE\nnu   1.0219 0.0541\n--\nChi-squared test for equidispersion\nX^2 = 0.1614, df = 1, p-value = 6.8788e-01\n--\nElapsed: 0.39 sec   Sample size: 730   formula interface\nLogLik: -2000.6310   AIC: 4009.2620   BIC: 4027.6341   \nOptimization Method: L-BFGS-B   Converged status: 0\nMessage: CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH\n```\n\n\n:::\n:::\n\n\n\nWe see some familiar results. Namely, the parameter estimates and p-values are pretty similar to the standard Poisson model [above](#modelformulation). However, there is additional output--this is where the dispersion comes in. When we fit the model, the function also estimated the value of the $\\nu$ parameter, which in this case was 1.022 (it was expected to be near 1, given that our data was generated from a standard Poisson distribution). The `X` components make up the regression equation for $\\lambda$, and the `S` components make up the regression equation for $\\nu$. We just need to evaluate those equations on an observation's covariate values, and we'll have its estimated conditional COM-Poisson distribution.\n\n## Testing for Violations of Equidispersion {#compoissonlrt}\n\nWe could just look at the estimated $\\nu$ parameter and its standard error in the model output to draw a conclusion about the dispersion. Nevertheless, the package also provides a function called `equitest` to more formally carry out a _likelihood ratio test (LRT)_ for the following hypotheses:\n\n$$H_0: \\nu = 1 \\hskip.25in H_A: \\nu \\neq 1$$\n\nIt tests for evidence that the data is _not_ equidispersed, but does not specify its direction. Therefore, if $H_0$ is rejected, it is up to us to garner from the model output whether there is over or under dispersion. Here is the output when performing this test on our model:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequitest(compoisson_model1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$teststat\n[1] 0.1613952\n\n$pvalue\n[1] 0.6878752\n\n$df\n[1] 1\n```\n\n\n:::\n:::\n\n\n\nAs expected, the p-value of 0.6879 does not indicate that over or under dispersion was detected.\n\n## Stratified Dispersion {#stratifieddispersion}\n\nOne of the coolest features of this modeling framework (in my opinion) is that not only can you fit a model for over or under dispersed data, but you can allow the dispersion parameter to vary by covariate values. You probably noticed the `formula.lambda` argument in the `glm.cmp` function call where we specified the model form for the $\\lambda$ parameter. There is an additional argument called `formula.nu` where we can analogously specify a linear predictor for the $\\nu$ parameter, which, like $\\lambda$, is on the _log_ scale. This means that, for example, if we suspect that one group has _overdispersed_ data, and another has _underdispersed_ data, we can account for that within a single model. Very cool! Just for kicks, let's see what this looks like when we allow the $\\nu$ parameter to vary between AM and PM hours from our `ed_volumes` dataset:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompoisson_model2 <-\n  glm.cmp(\n    formula.lambda = Volume ~ Weekend, # Linear predictor for log-lambda\n    formula.nu = Volume ~ PM, # Linear predictor for log-nu\n    data = \n      ed_volumes %>% \n      mutate(\n        Weekend = weekdays(Date) %in% c(\"Saturday\", \"Sunday\"),\n        PM = TimeOfDay == \"PM\"\n      )\n  )\ncompoisson_model2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCMP coefficients\n              Estimate     SE  z-value   p-value\nX:(Intercept)   2.8562 0.1532  18.6442 1.407e-77\nX:WeekendTRUE  -0.4231 0.0322 -13.1194 2.549e-39\nS:(Intercept)   0.0250 0.0530   0.4708    0.6378\nS:PMTRUE       -0.0064 0.0069  -0.9317    0.3515\n--\nChi-squared test for equidispersion\nX^2 = 1.0119, df = 2, p-value = 6.0295e-01\n--\nElapsed: 0.48 sec   Sample size: 730   formula interface\nLogLik: -2000.6243   AIC: 4009.2487   BIC: 4027.6208   \nOptimization Method: L-BFGS-B   Converged status: 0\nMessage: CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH\n```\n\n\n:::\n:::\n\n\n\nWe can see that there are now two parameters associated with the `S` component of the model. We can simply evaluate and exponentiate those terms to get the $\\nu$ estimates for each group:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make a simple design matrix\nnu_design <- matrix(c(1,1,0,1), nrow = 2)\n\n# Multiply by the S component of the model\nnu_log_estimates <- nu_design %*% as.matrix(compoisson_model2$gamma)\n\n# Exponentiate\nnu_estimates <- exp(nu_log_estimates)\n\n# Add the names\nrownames(nu_estimates) <- names(compoisson_model2$gamma)\nnu_estimates\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                  [,1]\nS:(Intercept) 1.025285\nS:PMTRUE      1.018696\n```\n\n\n:::\n:::\n\n\n\nAgain, both groups' data were knowingly generated from a standard Poisson distribution here, so we expected the conditional estimates to be near 1 as well. Nevertheless, it illustrates the power and flexibility of this framework. \n\n## Generating Fitted Values {#comfittedvalues}\n\nAs [previously mentioned](#compoissonmeanapprox), there is no closed form solution for the mean of a COM-Poisson random variable. So when we generate fitted values from the model's linear predictor, it is hard to conceptualize what they represent (it is _NOT_ the mean). Since our model _does_ produce estimates for both $\\lambda$ and $\\nu$, the [recommendation](https://projecteuclid.org/journals/annals-of-applied-statistics/volume-4/issue-2/A-flexible-regression-model-for-count-data/10.1214/09-AOAS306.full) is to plug these into the inverse cumulative density function (CDF) to obtain quantile-based fitted values. Specifically, we can use the _median_. The figure below displays the median and $25^{th}$/$75^{th}$ percentiles from the parameter grid used in the [simulation above](#centralitysimulation).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams %>%\n  \n  # Add the quantiles\n  inner_join(\n    y = \n      tibble(\n        Quantile = c(0.25, 0.50, 0.75)\n      ),\n    by = character()\n  ) %>%\n  \n  # Get the value\n  mutate(\n    Value = qcmp(Quantile, lambda, nu),\n    Linegroup = factor(Quantile == 0.50) %>% fct_rev(),\n    nu = \n      nu %>%\n      factor() %>%\n      fct_relabel(\n        function(x) paste0(\"nu == \", x)\n      )\n  ) %>%\n  \n  # Make a plot\n  ggplot(\n    aes(\n      x = lambda,\n      y = Value,\n      group = Quantile\n    )\n  ) +\n  geom_line(\n    aes(\n      linetype = Linegroup,\n      color = Linegroup\n    ),\n    size = 1.25\n  ) +\n  geom_point(\n    size = 2\n  ) +\n  facet_wrap(\n    ~nu,\n    scales = \"free_y\",\n    label = \"label_parsed\"\n  ) +\n  ylab(\"Median & 25th/75th Percentiles\") +\n  theme(\n    legend.position = \"none\",\n    axis.title = element_text(size = 14),\n    axis.text = element_text(size = 12),\n    strip.text = element_text(size = 12),\n    panel.background = element_blank(),\n    panel.grid.major.y = element_line(color = \"gray\")\n  ) +\n  scale_x_continuous(\n    breaks = unique(params$lambda)\n  ) +\n  labs(\n    x = expression(lambda)\n  ) +\n  scale_color_manual(\n    values = c(\"black\", \"red\")\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using `by = character()` to perform a cross join was deprecated in dplyr 1.1.0.\nℹ Please use `cross_join()` instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\nThe median values seem to have a relatively similar behavior to the simulated means.\n\nSo, to obtain _predicted_ values with our model object (we'll use the [first model we made](#compoissonregressionmodel)), we have to:\n\n1. Produce observation-level estimates of $\\lambda$ and $\\nu$ with the regression equation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Multiply the design matrices by the parameter estimates for each linear predictor, then exponentiate\nlambda_hat <- exp(compoisson_model1$X %*% as.matrix(compoisson_model1$beta))\nnu_hat <- exp(compoisson_model1$S %*% as.matrix(compoisson_model1$gamma))\nhead(data.frame(lambda_hat, nu_hat))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  lambda_hat   nu_hat\n1   17.23626 1.021921\n2   17.54978 1.021921\n3   17.23626 1.021921\n4   17.54978 1.021921\n5   17.23626 1.021921\n6   17.54978 1.021921\n```\n\n\n:::\n:::\n\n\n\n2. Plug the estimates into the inverse CDF at the 50th percentile\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny_hat <- qcmp(rep(0.5, length(lambda_hat)), lambda = lambda_hat, nu = nu_hat)\ntable(y_hat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ny_hat\n 11  16 \n208 522 \n```\n\n\n:::\n:::\n\n\n\nThere does exist a `predict.cmp` function that uses the [mean approximation](#compoissonmeanapprox) by default, so this could be used for fitted values as well if those conditions are satisfied.\n\n## Simulation: Power of Equidispersion Test {#compowersim}\n\nSo how well does the likelihood ratio test [described above](#compoissonlrt) detect over or under dispersion in the data-generating process? We can use simulation! To keep it simple, we will base it off of intercept-only regression models (i.e., no covariates), in effect assessing power at varying values of $\\lambda$. Presumably, power may depend on the complexity of the model, so coverage might vary as terms are added. Here are the parameter values we will consider:\n\n$$\n\\begin{equation}\n\\begin{split}\n\\lambda & = (1, 3, 5, 10, 25) \\\\\n\\nu & = (0.5, 0.75, 1, 1.25, 1.5, 2) \\\\\nN & = (25, 50, 100, 500) \\\\\n\\end{split}\n\\end{equation}\n$$\n\nWith those, we will take the following steps to carry out the simulation _for each combination of $\\lambda$, $\\nu$, and $N$_:\n\n1. Generate $N$ random COM-Poisson realizations\n2. Fit an intercept-only COM-Poisson regression model\n3. Conduct the likelihood ratio test for equidispersion\n4. Calculate the p-value from (3)\n5. Repeat steps 1-4 for 100 iterations\n6. Compute the proportion of iterations in (5) where the p-value was less than 0.05\n\nThe following code chunk carries out these steps:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# NOTE: THIS CHUNK TAKES A WHILE TO RUN\n\n# Number of iterations\nsims <- 100\n\npower_results <-\n  \n  # Parameter set\n  list(\n    lambda = c(1, 3, 5, 10, 25),\n    nu = c(0.5, 0.75, 1, 1.25, 1.5, 2),\n    N  = c(25, 50, 100, 500)\n  ) %>%\n  \n  # Get the cross product\n  cross_df() %>%\n  \n  # Split into a list\n  split(1:nrow(.)) %>%\n  \n  # For each parameter combination\n  map_df(\n    function(x) {\n      \n      # Generate all CMP realizations\n      tibble(\n        S = rep(1:sims, x$N),\n        Y = rcmp(n = x$N * sims, lambda = x$lambda, nu = x$nu)\n      ) %>%\n        \n        # For each iteration\n        group_by(S) %>%\n        \n        # Compute the p-value\n        summarise(\n          PValue = \n            tryCatch(\n              equitest(glm.cmp(Y ~ 1))$pvalue,\n              error = function(e) NA_real_\n            ),\n          .groups = \"drop\"\n        ) %>%\n        \n        # Add the parameter values\n        mutate(\n          lambda = x$lambda,\n          nu = x$nu,\n          N = x$N\n        )\n      \n    }\n  )\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nThis code took quite a while to run (~4 hours). I've noticed the fitting procedure takes a bit longer than we'd be used to with a simple `glm` call (which is probably expected given the complexity of the estimation), and varies depending on the combination of parameter values. It's also worth noting that it failed to converge on 0.9% of simulations, which tended to only occur when there was overdispersion ($\\nu=0.5$) with large counts ($\\lambda > 5$). Nevertheless, the figure below gives us the results of the simulation showing the estimated power for each parameter combination:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npower_results %>%\n  \n  # For each group\n  group_by(lambda, nu, N) %>%\n  \n  # Compute the power, and a measure of simulation error\n  summarise(\n    Power = mean(PValue <= 0.05, na.rm = TRUE),\n    SE = sd(PValue <= 0.05, na.rm = TRUE) / sqrt(n()),\n    .groups = \"drop\"\n  ) %>%\n  \n  # Make a factor\n  mutate(\n    N = factor(N),\n    nu = \n      nu %>%\n      factor() %>%\n      fct_relabel(\n        function(x) paste0(\"nu == \", x)\n      )\n  ) %>%\n  \n  # Make a plot\n  ggplot(\n    aes(\n      x = lambda,\n      y = Power\n    )\n  ) +\n  geom_line(\n    aes(\n      color = N\n    ),\n    size = 1\n  ) +\n  geom_point(\n    aes(\n      color = N\n    ),\n    size = 3\n  ) +\n  geom_ribbon(\n    aes(\n      ymin = Power - 2*SE,\n      ymax = Power + 2*SE,\n      fill = N\n    ),\n    alpha = .35\n  ) +\n  facet_wrap(\n    ~nu,\n    label = \"label_parsed\"\n  ) +\n  ylab(\"Power\") +\n  theme(\n    legend.position = \"top\",\n    axis.title = element_text(size = 14),\n    axis.text = element_text(size = 12),\n    strip.text = element_text(size = 12),\n    panel.background = element_blank(),\n    panel.grid.major.y = element_line(color = \"gray\")\n  ) +\n  scale_x_continuous(\n    breaks = unique(power_results$lambda)\n  ) +\n  labs(\n    x = expression(lambda)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\n**Findings**:\n\n* The power increases with sample size and deviation from $\\nu=1$\n* The test has a much harder time detecting over/under dispersion when the counts are really small (i.e., $\\lambda = 1$) \n* When there is overdispersion ($\\nu<1$), the power looks higher at lower values of $\\lambda$, but the opposite occurs as the data becomes more underdispersed\n\n# Conclusion {#conclusion}\n\nThe COM-Poisson regression framework is another tool in the toolbox to consider when modeling count data. Given that it is a generalization of the standard Poisson model that handles both over and under dispersed data, a good strategy may be to use it as a starting point to explore the variability in a dataset, and then shape the model from there. The likelihood ratio test allows us to test for violations of equidispersion, at which point we can use estimation to identify the direction that the dispersion exists. Since there are popular methods to handle overdispersed data (e.g., negative binomial models), the real void this method fills is its handling of underdispersed data--the challenge there may simply be finding the use case.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}