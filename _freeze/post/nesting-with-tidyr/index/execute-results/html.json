{
  "hash": "6996b1fc0e10b404417a458afc972538",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Nesting with {tidyr}\"\nauthor: \"Alex Zajichek\"\ndate: \"2/2/2023\"\nimage: \"feature.png\"\ncategories:\n  - Data Wrangling\nformat:\n  html:\n    code-fold: true\n    code-tools: true\n---\n\n\n\n\nI really love the elegance of the [`nest`](https://tidyr.tidyverse.org/reference/nest.html) functionality with the [`tidyr`](https://tidyr.tidyverse.org/) package. It really allows you to abstract the meaning of a data frame to not just contain rectangular data with scalars, but rather a generalization that has rectangular data of _objects_. The most intriguing part of it to me is the way we can continue to use typical [`join`](https://dplyr.tidyverse.org/reference/mutate-joins.html) operations even with complex objects in some of the columns, which makes it so smooth and intuitive to do complex data operations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\nFor example, lets say we have a dataset.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- cheese::heart_disease\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 303 × 9\n     Age Sex    ChestPain           BP Cholesterol BloodSugar MaximumHR\n   <dbl> <fct>  <fct>            <dbl>       <dbl> <lgl>          <dbl>\n 1    63 Male   Typical angina     145         233 TRUE             150\n 2    67 Male   Asymptomatic       160         286 FALSE            108\n 3    67 Male   Asymptomatic       120         229 FALSE            129\n 4    37 Male   Non-anginal pain   130         250 FALSE            187\n 5    41 Female Atypical angina    130         204 FALSE            172\n 6    56 Male   Atypical angina    120         236 FALSE            178\n 7    62 Female Asymptomatic       140         268 FALSE            160\n 8    57 Female Asymptomatic       120         354 FALSE            163\n 9    63 Male   Asymptomatic       130         254 FALSE            147\n10    53 Male   Asymptomatic       140         203 TRUE             155\n# ℹ 293 more rows\n# ℹ 2 more variables: ExerciseInducedAngina <fct>, HeartDisease <fct>\n```\n\n\n:::\n:::\n\n\n\nAnd we want to compute age percentiles by sex for those who do and don't have heart disease.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Nest data frames within sex, heart disease\nnested1 <-\n  dat %>%\n  group_by(Sex, HeartDisease) %>%\n  nest()\nnested1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n# Groups:   Sex, HeartDisease [4]\n  Sex    HeartDisease data              \n  <fct>  <fct>        <list>            \n1 Male   No           <tibble [92 × 7]> \n2 Male   Yes          <tibble [114 × 7]>\n3 Female No           <tibble [72 × 7]> \n4 Female Yes          <tibble [25 × 7]> \n```\n\n\n:::\n:::\n\n\n\nWe can see that there is now a separate dataset available within each combination of sex and heart disease status in the form of a `list` column.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the empirical cumulative density function for age\nnested2 <-\n  nested1 %>%\n  mutate(\n    ecdf_col = data %>% map(~ecdf(.x$Age))\n  )\nnested2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n# Groups:   Sex, HeartDisease [4]\n  Sex    HeartDisease data               ecdf_col\n  <fct>  <fct>        <list>             <list>  \n1 Male   No           <tibble [92 × 7]>  <ecdf>  \n2 Male   Yes          <tibble [114 × 7]> <ecdf>  \n3 Female No           <tibble [72 × 7]>  <ecdf>  \n4 Female Yes          <tibble [25 × 7]>  <ecdf>  \n```\n\n\n:::\n:::\n\n\n\nWe then apply `list` operations as we normally would. In this case, we use `purrr::map` to create an empirical cumulative density function for age within each group. The result is then just a `list` of `ecdf` functions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make an age grid\nage_grid <-\n  dat %>%\n  select(Sex, HeartDisease) %>%\n  distinct() %>%\n  inner_join(\n    y = tibble(Age = c(40, 50, 60, 70)),\n    by = character()\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using `by = character()` to perform a cross join was deprecated in dplyr 1.1.0.\nℹ Please use `cross_join()` instead.\n```\n\n\n:::\n\n```{.r .cell-code}\nage_grid\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 3\n   Sex    HeartDisease   Age\n   <fct>  <fct>        <dbl>\n 1 Male   No              40\n 2 Male   No              50\n 3 Male   No              60\n 4 Male   No              70\n 5 Male   Yes             40\n 6 Male   Yes             50\n 7 Male   Yes             60\n 8 Male   Yes             70\n 9 Female No              40\n10 Female No              50\n11 Female No              60\n12 Female No              70\n13 Female Yes             40\n14 Female Yes             50\n15 Female Yes             60\n16 Female Yes             70\n```\n\n\n:::\n:::\n\n\n\nWe then made an age grid for each sex/heart disease combination to evaluate the percentiles of each age in the respective groups. Now, we can compute the percentiles by joining to get the `ecdf` for the respective group, and plugging in each age into the function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage_grid %>% \n  \n  # Join to get the ecdf for the group\n  inner_join(\n    y = nested2 %>% select(-data),\n    by = c(\"Sex\", \"HeartDisease\")\n  ) %>%\n  \n  # Compute the percentile for the given age\n  mutate(\n    Percentile = map2(.x = ecdf_col, .y = as.list(Age), .f = ~.x(.y)) %>% flatten_dbl()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 5\n   Sex    HeartDisease   Age ecdf_col Percentile\n   <fct>  <fct>        <dbl> <list>        <dbl>\n 1 Male   No              40 <ecdf>       0.0761\n 2 Male   No              50 <ecdf>       0.424 \n 3 Male   No              60 <ecdf>       0.859 \n 4 Male   No              70 <ecdf>       1     \n 5 Male   Yes             40 <ecdf>       0.0526\n 6 Male   Yes             50 <ecdf>       0.246 \n 7 Male   Yes             60 <ecdf>       0.719 \n 8 Male   Yes             70 <ecdf>       0.991 \n 9 Female No              40 <ecdf>       0.0694\n10 Female No              50 <ecdf>       0.361 \n11 Female No              60 <ecdf>       0.694 \n12 Female No              70 <ecdf>       0.931 \n13 Female Yes             40 <ecdf>       0     \n14 Female Yes             50 <ecdf>       0.04  \n15 Female Yes             60 <ecdf>       0.52  \n16 Female Yes             70 <ecdf>       1     \n```\n\n\n:::\n:::\n\n\n\nWe can see, for example, that a 60 year old male is at the $86^{th}$ percentile for those without heart disease, but at the $72^{nd}$ for those who due, suggesting that the age distribution tends to be higher in patients with heart disease.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}