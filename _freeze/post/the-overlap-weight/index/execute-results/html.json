{
  "hash": "065f902fb28ceffa1c092036ebb65ed9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The overlap weight in survival analysis\"\ndescription: \"A simulation review\"\nauthor: \"Alex Zajichek\"\ndate: \"10/2/2023\"\nimage: \"feature.png\"\ncategories:\n  - Causal Inference\n  - Survival Analysis\n  - Propensity Scores\n  - Weighting\nformat:\n  html:\n    code-fold: true\n    code-tools: true\n---\n\n\n\n\n\nI was recently introduced to [overlap weighting](https://jamanetwork.com/journals/jama/article-abstract/2765748), which is part of a general family of methods for balancing covariates when estimating treatment effects with observational data. Specifically, it focuses on the [_clinical equipoise_](https://www.sciencedirect.com/topics/medicine-and-dentistry/clinical-equipoise#:~:text=Clinical%20equipoise%20is%20defined%20as,Seminars%20in%20Vascular%20Surgery%2C%202022); that is, the patients in which the treatment decision is most uncertain. I find it more elegant than [matching](https://en.wikipedia.org/wiki/Propensity_score_matching) (which I've [used in the past](https://jamanetwork.com/journals/jama/fullarticle/2749478)), and figured a useful way to better understand the approach is to deconstruct, interpret, and translate a [SAS simulation](http://www2.stat.duke.edu/~fl35/OW/OW_survival_Demo.sas) in the context of survival analysis implemented by the [original authors](https://pubmed.ncbi.nlm.nih.gov/30189042/). All code is written in (and translated to) [`R`](https://www.r-project.org/). We'll start by loading some packages.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(survival)\nlibrary(reactable)\n```\n:::\n\n\n\n# Table of Contents\n\n* [Setting up the potential outcomes](#potentialoutcomes)\n  + [Simulate some patients](#simulatepatients)\n  + [Define the treatment propensity](#treatmentpropensity)\n  + [Generate the treatment assignment](#treatmentassignment)\n  + [Compute the (true) overlap weight](#trueoverlapweight)\n  + [Set the treatment effect](#treatmenteffect)\n  + [Assign the observed outcome](#observedoutcome)\n* [Estimating the weights](#estimatingweights)\n  + [Model the propensity scores](#modelpropensityscores)\n  + [Calculate the (estimated) overlap weight](#estimatedoverlapweight)\n* [Estimating the treatment effect](#estimatingtreatmenteffect)\n  + [A look at the true hazard ratio](#truehazardratio)\n  + [The final estimate](#estimatedhazardratio)\n\n# Setting up the potential outcomes {#potentialoutcomes}\n\nThe theoretical underpinnings of [overlap weighting](https://pubmed.ncbi.nlm.nih.gov/30189042/) live in the context of the [potential outcomes](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5841618/#:~:text=The%20potential%20outcomes%20framework%20provides%20a%20way%20to%20quantify%20causal,exposure%20or%20intervention%20under%20consideration.) paradigm of [causal inference](https://www.sciencedirect.com/topics/social-sciences/causal-inference). Basically, we wonder what _would have_ happened had we been able to observe each patient under both treatments (known as the [counterfactual](https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/1471-2288-5-28)). If we knew the outcomes from the two worlds, the causal treatment effect would simply be the average difference across all patients. The problem of course is that in reality the outcome can only be observed for the treatment in which the patient was assigned (or chose), and so our goal is to work with the \"incomplete\" information that we do have to try to estimate what the outcome difference would have been had the counterfactual been observed as well.\n\n## Simulate some patients {#simulatepatients}\n\nThe first thing we need to do is generate some (fake) patients to facilitate the simulation. Here we'll focus on age, sex, and income as patient-identifying characteristics.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the sample size\nn <- 10000\n\n# Set the seed\nset.seed(123)\n\n# Build the population\npopulation <-\n  tibble(\n    age = rnorm(n, mean = 50, sd = 10),\n    zage = (age - 50) / 10,\n    male = rbinom(n, size = 1, prob = 0.6),\n    income = rnorm(n, mean = 50, sd = 10),\n    zincome = (income - 50) / 10\n  )\npopulation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,000 × 5\n     age    zage  male income zincome\n   <dbl>   <dbl> <int>  <dbl>   <dbl>\n 1  44.4 -0.560      0   36.5  -1.35 \n 2  47.7 -0.230      1   44.2  -0.579\n 3  65.6  1.56       1   41.4  -0.861\n 4  50.7  0.0705     1   59.7   0.973\n 5  51.3  0.129      0   56.2   0.619\n 6  67.2  1.72       1   63.9   1.39 \n 7  54.6  0.461      1   35.1  -1.49 \n 8  37.3 -1.27       1   56.4   0.639\n 9  43.1 -0.687      1   53.7   0.375\n10  45.5 -0.446      1   53.7   0.370\n# ℹ 9,990 more rows\n```\n\n\n:::\n:::\n\n\n\nWe've generated a sample of 10000 patients. We'll assume `age` is measured in years, `income` in thousands of dollars (\\$), and `male` is 1 for _Male_ and 0 for _Female_. The columns `zage` and `zincome` are just [standardized](https://statisticsbyjim.com/glossary/standardization/#:~:text=In%20statistics%2C%20standardization%20is%20the,standard%20deviation%20for%20a%20variable.) versions of the originals to avoid scaling nuances (we'll refer to these as $age_z$ and $income_z$).\n\n## Define the treatment propensity {#treatmentpropensity}\n\nHere's where the important theory starts to creep in (already). We assume that there is a _true_ propensity score, say $p_i^A$, that is the _true_ probability that patient _i_ receives treatment _A_ given their specific characteristics (and let's assume there are possible treatments _A_ & _B_). Further, we assume (some transformation of) this probability is a linear combination of all the characteristics that confound the crude treatment effect on the outcome. In this simulation, we'll assume the [logit](https://en.wikipedia.org/wiki/Logistic_regression) model:\n\n$$log(\\frac{p_i^A}{1 - p_i^A}) = 0.41 \\times age_z - 0.22 \\times male - 0.69 \\times income_z - 0.40$$\n\nSo let's add this _true_ propensity score to the `population` data set:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation <-\n  population |>\n  \n  # Add the true propensity score (unknown quantity)\n  mutate(\n    log_odds_pA = -0.4 + log(1.5)*zage + log(0.8)*male + log(.50)*zincome,\n    pA = 1 / (1 + exp(-log_odds_pA))\n  )\npopulation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,000 × 7\n     age    zage  male income zincome log_odds_pA    pA\n   <dbl>   <dbl> <int>  <dbl>   <dbl>       <dbl> <dbl>\n 1  44.4 -0.560      0   36.5  -1.35        0.311 0.577\n 2  47.7 -0.230      1   44.2  -0.579      -0.315 0.422\n 3  65.6  1.56       1   41.4  -0.861       0.606 0.647\n 4  50.7  0.0705     1   59.7   0.973      -1.27  0.219\n 5  51.3  0.129      0   56.2   0.619      -0.777 0.315\n 6  67.2  1.72       1   63.9   1.39       -0.888 0.292\n 7  54.6  0.461      1   35.1  -1.49        0.595 0.644\n 8  37.3 -1.27       1   56.4   0.639      -1.58  0.171\n 9  43.1 -0.687      1   53.7   0.375      -1.16  0.238\n10  45.5 -0.446      1   53.7   0.370      -1.06  0.257\n# ℹ 9,990 more rows\n```\n\n\n:::\n:::\n\n\n\nObviously in practice we don't know what $p_i^A$ is, so it must be _estimated_ from the treatment assignments we observe in the data. Additionally, we aren't strictly required to assume the [logit](https://en.wikipedia.org/wiki/Logistic_regression) model, but when we use it to estimate the propensity score for [overlap weighting](https://pubmed.ncbi.nlm.nih.gov/30189042/), it has the advantageous property of perfect balance. That is, the weighted-mean differences for all covariates included in the logistic regression model will be zero across the treatment groups.\n\n## Generate the treatment assignment {#treatmentassignment}\n\nThe treatment assignment is one of the _known_ quantities we would observe in a real life sample, and that is what would be used as the dependent variable for _estimating_ propensity scores. However, since we are running a simulation, we need to generate the treatment assignments from the governing distribution. We assume that the observed treatment for patient _i_ is the result of an (unfair) coin flip that has a probability equal to the [true propensity score](#treatmentpropensity). In statistical notation,\n\n$$A_i \\sim Bernoulli(p_i^A)$$\n\nwhere $A_i$ is the indicator of treatment A. Let's add a _realized_ treatment assignment to the `population`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation <-\n  population |>\n  \n  # Add the realized treatment assignment (known quantity)\n  mutate(\n    A = rbinom(n, size = 1, prob = pA),\n  )\npopulation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,000 × 8\n     age    zage  male income zincome log_odds_pA    pA     A\n   <dbl>   <dbl> <int>  <dbl>   <dbl>       <dbl> <dbl> <int>\n 1  44.4 -0.560      0   36.5  -1.35        0.311 0.577     1\n 2  47.7 -0.230      1   44.2  -0.579      -0.315 0.422     0\n 3  65.6  1.56       1   41.4  -0.861       0.606 0.647     1\n 4  50.7  0.0705     1   59.7   0.973      -1.27  0.219     0\n 5  51.3  0.129      0   56.2   0.619      -0.777 0.315     1\n 6  67.2  1.72       1   63.9   1.39       -0.888 0.292     1\n 7  54.6  0.461      1   35.1  -1.49        0.595 0.644     0\n 8  37.3 -1.27       1   56.4   0.639      -1.58  0.171     0\n 9  43.1 -0.687      1   53.7   0.375      -1.16  0.238     0\n10  45.5 -0.446      1   53.7   0.370      -1.06  0.257     0\n# ℹ 9,990 more rows\n```\n\n\n:::\n:::\n\n\n\nIn this case, `A=1` represents treatment _A_ and `A=0` represents treatment _B_. Again, this is the actual treatment we would observe the patient receiving in a sample.\n\n## Compute the (true) overlap weight {#trueoverlapweight}\n\nWe need to define what the overlap weight is, and it's actually quite simple: just assign the patient the probability they _did not_ receive their observed treatment. \n\n$$\n\\begin{equation}\nOW_i=\n    \\begin{cases}\n        1-p_i^A & \\text{if } A_i=1\\\\\n        p_i^A & \\text{if } A_i=0\\\\\n    \\end{cases}\n\\end{equation}\n$$\n\nNotice the notation. Since it depends on the [true propensity score](#treatmentpropensity), the overlap weight is another _unknown_ quantity that is estimated from the data. It also depends on the [realized treatment assignment](#treatmentassignment), so the collection of weights across patients differ depending on the observed treatment distribution. We can add these weights to the `population` data set:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation <-\n  population |>\n  \n  # Add the true overlap weight for the realized treatment (unknown quantity)\n  mutate(\n    OW = A * (1-pA) + (1-A) * pA\n  )\npopulation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,000 × 9\n     age    zage  male income zincome log_odds_pA    pA     A    OW\n   <dbl>   <dbl> <int>  <dbl>   <dbl>       <dbl> <dbl> <int> <dbl>\n 1  44.4 -0.560      0   36.5  -1.35        0.311 0.577     1 0.423\n 2  47.7 -0.230      1   44.2  -0.579      -0.315 0.422     0 0.422\n 3  65.6  1.56       1   41.4  -0.861       0.606 0.647     1 0.353\n 4  50.7  0.0705     1   59.7   0.973      -1.27  0.219     0 0.219\n 5  51.3  0.129      0   56.2   0.619      -0.777 0.315     1 0.685\n 6  67.2  1.72       1   63.9   1.39       -0.888 0.292     1 0.708\n 7  54.6  0.461      1   35.1  -1.49        0.595 0.644     0 0.644\n 8  37.3 -1.27       1   56.4   0.639      -1.58  0.171     0 0.171\n 9  43.1 -0.687      1   53.7   0.375      -1.16  0.238     0 0.238\n10  45.5 -0.446      1   53.7   0.370      -1.06  0.257     0 0.257\n# ℹ 9,990 more rows\n```\n\n\n:::\n:::\n\n\n\nIn a real analysis, these weights are what we are ultimately after in order to estimate the average _causal_ treatment effect on the outcome of interest while balancing differences in patient characteristics across the groups (i.e., removing the confounding factors).\n\n### Target population {#targetpopulation}\n\nNow we do end up normalizing the weights so they sum to one within each treatment group. But the intuition about what's happening is that the focus of the treatment effect estimation is shifted to patients that are most likely in _either_ treatment group. This is known as the [_clinical equipoise_](https://www.sciencedirect.com/topics/medicine-and-dentistry/clinical-equipoise#:~:text=Clinical%20equipoise%20is%20defined%20as,Seminars%20in%20Vascular%20Surgery%2C%202022), and the resulting treatment effect is interpreted as the _average treatment effect in the overlap population_.\n\nThis makes a lot of sense. When we're comparing treatments, we should focus most heavily on patients that could be candidates for either, and less so on patients that were bound for one. Thus, we up-weight patients who have the most overlap in characteristics with the opposing treatment group. The beautiful thing here is that we do this without throwing away any information; smoothly and proportionately weighting each subject just the amount that we should.\n\n## Set the treatment effect {#treatmenteffect}\n\nWe've [generated the treatments](#treatmentassignment) and established how they are [related to patient characteristics](#treatmentpropensity), but haven't talked about the outcome in which we're ultimately interested in estimating the treatment effect for. Since we're focusing on [time-to-event](https://www.publichealth.columbia.edu/research/population-health-methods/time-event-data-analysis) outcomes, we'll stay in that context, but the general idea is that we assume there _exists_ a realization of what a patient's outcome would have been under each treatment scenario. Then if we compare the difference of those outcomes across all patients, the average difference must be caused by the treatment.\n\n### Defining the event times\n\nIn this simulation, we'll generate event times from a [Weibull](https://en.wikipedia.org/wiki/Weibull_distribution) distribution. Starting at treatment initiation, this might be the time until cancer recurrence, hospitalization, or something else; we're just looking to see how long it takes for some event to occur. The [PDF](https://en.wikipedia.org/wiki/Probability_density_function) for this distribution looks [like this](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/Weibull.html):\n\n$$f(t) = \\frac{\\alpha}{\\sigma}\\left(\\frac{t}{\\sigma}\\right)^{\\alpha-1}e^{-\\left(\\frac{t}{\\sigma}\\right)^\\alpha}$$\n\nwhere $t$ is the event time, $\\alpha$ is the _shape_ parameter, and $\\sigma$ is the _scale_ parameter. In our example, we will say that:\n\n$$T_i^A \\sim Weibull(\\alpha, \\sigma_i^A)$$\n$$T_i^B \\sim Weibull(\\alpha, \\sigma_i^B)$$\nwhere $T_i^A$ and $T_i^B$ are the event times under treatments _A_ and _B_, respectively. That is, the event times for each patient under each treatment follow a [Weibull](https://en.wikipedia.org/wiki/Weibull_distribution) distribution with a common _shape_ parameter (in this case, across both treatments), but a _scale_ parameter that depends on the patient's specific characteristics (in _log-linear_ form) and differs by treatment, which captures the treatment effect. Specifically,\n\n$$\\alpha = 1$$\n$$\\sigma_i^A = \\lambda \\times e^{-(\\phi_i - 0.36)}$$\n$$\\sigma_i^B = \\lambda \\times e^{-\\phi_i}$$\n$$\\phi_i = 1.10 \\times age_z - 0.22 \\times male - 0.36 \\times income_z$$\n$$\\lambda = 4055.56$$\n\nBasically, the $\\phi_i$ term does the baseline adjustment on the outcome risk for the patient's specific characteristics, and the treatment effect is simply a fixed, additive deviation from that for all patients. The $\\lambda$ term is the [baseline hazard function](https://www.linkedin.com/advice/0/how-do-you-interpret-hazard-ratio-baseline-function), providing the _scale_ parameter when all covariate values are zero (for treatment _B_), which in this case is constant over time. \n\n#### Interpreting the treatment effect {#interpretingtreatmenteffect}\n\nWhen setting $\\alpha=1$, the mean of a [Weibull](https://en.wikipedia.org/wiki/Weibull_distribution) distribution is equal to its scale parameter. That is,\n\n$$E[T_i^A] = \\sigma_i^A$$\n$$E[T_i^B] = \\sigma_i^B$$\nThis gives us a very nice interpretation of the treatment effect. If we compare them _relatively_, we get:\n\n$$\n\\begin{equation} \n\\begin{split}\n\\frac{E[T_i^A]}{E[T_i^B]} & = \\frac{\\sigma_i^A}{\\sigma_i^B} \\\\\n& = \\frac{\\lambda \\times e^{-(\\phi_i - 0.36)}}{\\lambda \\times e^{-\\phi_i}} \\\\\n& = \\frac{e^{-(\\phi_i - 0.36)}}{e^{-\\phi_i}} \\\\\n& = \\frac{e^{0.36}e^{-\\phi_i}}{e^{-\\phi_i}} \\\\\n& = e^{0.36} \\\\\n& \\approx 1.43\n\\end{split}\n\\end{equation}\n$$\n\nSo we can say that the _time to event for patients on treatment A is 1.43 times, or 43%, longer on average than those on treatment B, given a fixed age, sex, and income_. That is, treatment A is \"better\" than treatment B.\n\n### Sampling the event times {#samplingeventtimes}\n\nNext, we need to actually sample the times for our `population` (_note that it was confirmed that SAS and R have the same parameterizations_):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation <-\n  population |>\n  \n  # Sample outcome event times under each treatment (counterfactual)\n  mutate(\n    \n    # Baseline hazard (constant over time)\n    lambda = 1*365/0.09,\n    \n    # Define TRUE Weibull linear predictor\n    phi = log(3) * zage + log(0.8) * male + log(.70) * zincome,\n    sigma_A = lambda * exp(-(phi + log(0.70))),\n    sigma_B = lambda * exp(-phi),\n    \n    # Generate REALIZED survival times under each treatment scenario (same parameterizations in SAS)\n    t_A = rweibull(n, shape = 1, scale = sigma_A),\n    t_B = rweibull(n, shape = 1, scale = sigma_B), \n  )\npopulation |> select(lambda, phi, sigma_A, sigma_B, t_A, t_B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,000 × 6\n   lambda     phi sigma_A sigma_B    t_A   t_B\n    <dbl>   <dbl>   <dbl>   <dbl>  <dbl> <dbl>\n 1  4056. -0.133    6617.   4632.  5689. 7760.\n 2  4056. -0.269    7585.   5309.  1831. 9482.\n 3  4056.  1.80      961.    673.   488.  300.\n 4  4056. -0.493    9482.   6637. 23722.  255.\n 5  4056. -0.0788   6269.   4388.  7649. 1800.\n 6  4056.  1.17     1804.   1263.  1953. 1493.\n 7  4056.  0.814    2568.   1797.  5462. 2652.\n 8  4056. -1.84    36514.  25560. 38262. 2385.\n 9  4056. -1.11    17604.  12323.  3577. 6894.\n10  4056. -0.845   13485.   9439. 38541. 3743.\n# ℹ 9,990 more rows\n```\n\n\n:::\n:::\n\n\n\nNow we can make some density plots comparing the event time distributions across treatments (we'll use _log_ scaling for visual appeal):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation |>\n  \n  # Send down the rows\n  pivot_longer(\n    cols = starts_with(\"t_\"),\n    names_to = \"Treatment\",\n    values_to = \"EventTime\",\n    names_prefix = \"t_\"\n  ) |> \n  \n  # Make a plot\n  ggplot() + \n  geom_density(\n    aes(\n      x = log(EventTime),\n      fill = Treatment\n    ),\n    alpha = .75\n  ) + \n  scale_x_continuous(labels = function(x) round(exp(x))) +\n  theme(\n    panel.background = element_blank(),\n    axis.ticks.y = element_blank(),\n    axis.text.y = element_blank(),\n    axis.title.y = element_blank(),\n    legend.position = \"top\"\n  ) +\n  xlab(\"Event Time\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\nNotice the shift to the right in the distribution for treatment _A_. This is the treatment effect. In the hypothetical world where all patients received treatment _A_, the event times happened _later_ than in the world where all patients received treatment _B_ (and all event times were observed), indicating, on average, a \"benefit\" to treatment _A_, which was expected from our [prior calculation](#interpretingtreatmenteffect).\n\n## Assign the observed outcome {#observedoutcome}\n\nThe final step for simulation setup is to assign the event time as we might observe in a real data set. The event times generated in the [previous section](#samplingeventtimes) capture both treatment scenarios for all patients, but in reality we would only (potentially) observe the event time for the [treatment the patient received](#treatmentassignment). Additionally, we likely (or definitely) won't be following all patients long enough to observe all events occur, meaning some patients will be [censored](https://en.wikipedia.org/wiki/Survival_analysis#:~:text=Censoring%20%2F%20Censored%20observation%3A%20Censoring%20occurs,after%20the%20time%20of%20censoring.). Let's add the observed outcomes to the `population`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation <-\n  population |> \n  \n  # Add the observed outcome\n  mutate(\n    \n    # The ACTUAL event time outcome depends on the treatment ACTUALLY observed for the patient\n    actual_event_time = t_B * (1 - A) + t_A * A,\n    \n    # Generate a REALIZED censoring time (completely random)\n    censor_time = 500 + 500 * runif(n),\n    \n    # Calculate the OBSERVED time in the data set (known quantity)\n    time = pmin(actual_event_time, censor_time), # They either had the event, or were censored first\n    \n    # Calculate the event status (TRUE if event observed, FALSE if censored)\n    status = as.numeric(actual_event_time < censor_time)\n  )\npopulation |> select(actual_event_time, censor_time, time, status)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,000 × 4\n   actual_event_time censor_time  time status\n               <dbl>       <dbl> <dbl>  <dbl>\n 1             5689.        843.  843.      0\n 2             9482.        814.  814.      0\n 3              488.        882.  488.      1\n 4              255.        936.  255.      1\n 5             7649.        653.  653.      0\n 6             1953.        890.  890.      0\n 7             2652.        737.  737.      0\n 8             2385.        703.  703.      0\n 9             6894.        952.  952.      0\n10             3743.        526.  526.      0\n# ℹ 9,990 more rows\n```\n\n\n:::\n:::\n\n\n\nOur final simulated data set has the following _observed_ outcome summaries:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation |>\n  \n  # Compute summary metrics\n  summarize(\n    Patients = n(),\n    Time = mean(time),\n    .by = c(A, status)\n  ) |> \n  \n  # Add shares within treatment\n  mutate(\n    Percent = Patients / sum(Patients),\n    .by = A\n  ) |>\n  \n  # Clean/rearrange\n  transmute(\n    Treatment = \n      case_when(\n        A == 1 ~ \"A\",\n        TRUE ~ \"B\"\n      ),\n    Status = \n      case_when(\n        status == 1 ~ \"Event\",\n        TRUE ~ \"Censored\"\n      ),\n    Patients,\n    Percent,\n    Time\n  ) |>\n  arrange(Treatment, desc(Status)) |>\n  \n  # Make a table\n  reactable(\n    groupBy = \"Treatment\",\n    columns = \n      list(\n        Patients = colDef(aggregate = \"sum\", align = \"center\"),\n        Percent = colDef(name = \"Percent of patients in treatment group (%)\", aggregate = \"sum\", align = \"center\", format = colFormat(digits = 1, percent = TRUE)),\n        Time = colDef(name = \"Avg. time to outcome\", aggregate = zildge::rectbl_agg_wtd(\"Patients\"), align = \"center\", format = colFormat(digits = 1))\n      ),\n    striped = TRUE,\n    highlight = TRUE,\n    bordered = TRUE,\n    resizable = TRUE,\n    theme = reactablefmtr::sandstone()\n  ) |>\n  reactablefmtr::add_source(\"Use arrows to expand table\", font_size = 12, font_style = \"italic\")\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"reactable html-widget html-fill-item\" id=\"htmlwidget-a2195d80fa4b22595ce8\" style=\"width:auto;height:auto;\"></div>\n<p style=\"color:#000;background:#FFFFFF;text-align:left;font-size:12px;font-style:italic;font-weight:normal;text-decoration:;letter-spacing:px;word-spacing:px;text-transform:;text-shadow:;margin-top:0px;margin-right:0px;margin-bottom:0px;margin-left:0px\">Use arrows to expand table</p>\n<script type=\"application/json\" data-for=\"htmlwidget-a2195d80fa4b22595ce8\">{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"Treatment\":[\"A\",\"A\",\"B\",\"B\"],\"Status\":[\"Event\",\"Censored\",\"Event\",\"Censored\"],\"Patients\":[836,3046,1137,4981],\"Percent\":[0.215352910870685,0.784647089129315,0.185845047401111,0.814154952598888],\"Time\":[345.503703338068,745.228837321148,343.475165801799,746.272923924017]},\"columns\":[{\"id\":\"Treatment\",\"name\":\"Treatment\",\"type\":\"character\"},{\"id\":\"Status\",\"name\":\"Status\",\"type\":\"character\"},{\"id\":\"Patients\",\"name\":\"Patients\",\"type\":\"numeric\",\"aggregate\":\"sum\",\"align\":\"center\"},{\"id\":\"Percent\",\"name\":\"Percent of patients in treatment group (%)\",\"type\":\"numeric\",\"aggregate\":\"sum\",\"format\":{\"cell\":{\"digits\":1,\"percent\":true},\"aggregated\":{\"digits\":1,\"percent\":true}},\"align\":\"center\"},{\"id\":\"Time\",\"name\":\"Avg. time to outcome\",\"type\":\"numeric\",\"aggregate\":\"function(values, rows) {\\n            var numerator = 0\\n            var denominator = 0\\n\\n            rows.forEach(function(row, index) {\\n                numerator += row['Patients'] * values[index]\\n                denominator += row['Patients']\\n            })\\n\\n            if('mean' == 'mean') {\\n                return numerator / denominator\\n            } else {\\n                return numerator\\n            }\\n        }\",\"format\":{\"cell\":{\"digits\":1},\"aggregated\":{\"digits\":1}},\"align\":\"center\"}],\"groupBy\":[\"Treatment\"],\"resizable\":true,\"highlight\":true,\"bordered\":true,\"striped\":true,\"theme\":{\"color\":\"#3e3f3a\",\"backgroundColor\":\"#ffffff\",\"borderColor\":\"#f8f5f0\",\"borderWidth\":\"1px\",\"stripedColor\":\"#ededed\",\"highlightColor\":\"#f8f5f0\",\"cellPadding\":6,\"tableStyle\":{\"fontSize\":15},\"headerStyle\":{\"borderWidth\":\"2px\",\"backgroundColor\":\"#f8f5f0\",\"color\":\"#7c7a78\",\"transitionDuration\":\"0.5s\",\"&:hover[aria-sort]\":{\"color\":\"#000000\"},\"&[aria-sort='ascending'], &[aria-sort='descending']\":{\"color\":\"#000000\"},\"fontSize\":16},\"groupHeaderStyle\":{\"&:not(:empty)\":{\"color\":\"#3e3f3a\",\"fontSize\":16},\"&:hover\":{\"fontWeight\":\"bold\",\"transitionDuration\":\"1s\",\"transitionTimingFunction\":\"ease-out\",\"color\":\"#000000\"}},\"rowSelectedStyle\":{\"backgroundColor\":\"#dfd7ca\",\"color\":\"#8e8c84\"},\"inputStyle\":{\"backgroundColor\":\"#ffffff\",\"borderColor\":\"#bcbfc1\",\"color\":\"#3e3f3a\"},\"searchInputStyle\":{\"backgroundColor\":\"#ffffff\",\"color\":\"#3e3f3a\",\"borderColor\":\"#bcbfc1\",\"&:focus\":{\"color\":\"#3e3f3a\"}},\"selectStyle\":{\"backgroundColor\":\"#dfd7ca\",\"color\":\"#8e8c84\",\"borderColor\":\"#ffffff\",\"outlineColor\":\"#ffffff\"},\"pageButtonStyle\":{\"backgroundColor\":\"#f8f5f0\",\"color\":\"#8e8c84\",\"&:hover\":{\"backgroundColor\":\"#f3969a\",\"color\":\"#8e8c84\"}},\"pageButtonHoverStyle\":{\"backgroundColor\":\"#dfd7ca\",\"color\":\"#8e8c84\"},\"pageButtonActiveStyle\":{\"backgroundColor\":\"#dfd7ca\",\"color\":\"#8e8c84\"},\"pageButtonCurrentStyle\":{\"backgroundColor\":\"#dfd7ca\",\"color\":\"#8e8c84\"}},\"dataKey\":\"803f0e909881888862e5822d6c0d5d1e\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[\"tag.attribs.columns.4.aggregate\"],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n<br>\n\nWe can also look at the survival curves.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation |>\n  \n  # Nest by treatment\n  group_by(A) |>\n  nest() |>\n  \n  # Esimtate survival curves for each treatment\n  mutate(\n    Surv = \n      data |>\n      map(\n        function(.trt) {\n          \n          # Fit the model\n          mod <- survfit(Surv(time, status) ~ 1, data = .trt)\n          \n          # Extract the elements\n          tibble(\n            Time = mod$time,\n            Survival = mod$surv,\n            Lower = mod$lower,\n            Upper = mod$upper\n          )\n          \n        }\n      )\n  ) |> \n  \n  # Unnest the curves\n  select(-data) |>\n  unnest(cols = Surv) |>\n  ungroup() |>\n\n  # Clean labels\n  mutate(\n    Treatment = \n      case_when(\n        A == 1 ~ \"A\",\n        TRUE ~ \"B\"\n      )\n  ) |>\n  \n  # Make a plot\n  ggplot(\n    aes(\n      x = Time,\n      y = Survival\n    )\n  ) + \n  geom_line(aes(color = Treatment)) +\n  geom_ribbon(\n    aes(\n      ymin = Lower,\n      ymax = Upper,\n      fill = Treatment\n    ),\n    alpha = .25\n  ) +\n  scale_y_continuous(labels = scales::percent) +\n  theme(\n    panel.background = element_blank(),\n    panel.grid.major.y = element_line(color = \"gray\"),\n    legend.position = \"top\"\n  ) +\n  xlab(\"Time since treatment\") +\n  ylab(\"Survival Probability\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nIf we weren't doing a simulation, we wouldn't know how much of these differences are explained by the treatment. And actually, these crude survival curves suggest longer survival from treatment _B_, even though we know the [opposite is true](#treatmenteffect). The goal is to use this _known_ information (along with [patient characteristics](#simulatepatients)) to estimate the causal treatment effect that is baked into all of the _unknown_ quantities we have here that would be unavailable to us in a real-life analysis.\n\n# Estimating the weights {#estimatingweights}\n\nNow that our [simulation is set](#potentialoutcomes), we can start using the observed data (i.e., known quantities) to estimate the case-weights needed for treatment effect estimation. This is the process we'd go through in a real-life analysis, but here we have the benefit of knowing the truth, so we can see how close our estimations are to reality. \n\nThe intention of these weights is to _adjust_ the observed sample to create a _pseudo-population_ such that the patient characteristics that we believe are confounding the treatment effect are corrected for, or _balanced_, across the treatment groups. The term \"pseudo\" here is a little misleading. It's simply referring to the fact that each patient will not contribute the same weight in estimating the treatment effect. In fact, the patients with the most _overlap_ in characteristics across the treatment groups will contribute the most, with patients being proportionately down-weighted the less overlap they have (I'd argue this is the same thing that is done in [matching](https://en.wikipedia.org/wiki/Propensity_score_matching), it's just that the weights for patients are either exactly _1_ or _0_). This is done to tease out the portion of the outcome differences that is explained by the treatment, namely, the causal treatment effect. \n\n## Model the propensity scores {#modelpropensityscores}\n\nWe've [established](#trueoverlapweight) that the overlap weights are quantities that need to be estimated from the data. In order to calculate those weights, we first need to estimate the propensity scores. We know what the [true model](#treatmentpropensity) is, but let's assume we are only working with observable data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation |> select(zage, male, zincome, A, time, status)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,000 × 6\n      zage  male zincome     A  time status\n     <dbl> <int>   <dbl> <int> <dbl>  <dbl>\n 1 -0.560      0  -1.35      1  843.      0\n 2 -0.230      1  -0.579     0  814.      0\n 3  1.56       1  -0.861     1  488.      1\n 4  0.0705     1   0.973     0  255.      1\n 5  0.129      0   0.619     1  653.      0\n 6  1.72       1   1.39      1  890.      0\n 7  0.461      1  -1.49      0  737.      0\n 8 -1.27       1   0.639     0  703.      0\n 9 -0.687      1   0.375     0  952.      0\n10 -0.446      1   0.370     0  526.      0\n# ℹ 9,990 more rows\n```\n\n\n:::\n:::\n\n\n\nOur goal is to obtain patient-specific probabilities of receiving treatment _A_. We'll estimate this with a [logistic regression](https://en.wikipedia.org/wiki/Logistic_regression) model, but we'll allow for some flexibility in the shape of the relationships between the continuous variables (age and income) and the outcome with the use of [restricted cubic splines](https://www.nature.com/articles/s41409-019-0679-x) (see my [other post](https://www.zajichekstats.com/post/the-evasive-spline/) for another explanation):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit the propensity score model\nps_mod <-\n  glm(\n    formula = A ~ rms::rcs(zage, 3) + rms::rcs(zincome, 3) + factor(male),\n    data = population,\n    family = \"binomial\"\n  )\nsummary(ps_mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm(formula = A ~ rms::rcs(zage, 3) + rms::rcs(zincome, 3) + \n    factor(male), family = \"binomial\", data = population)\n\nCoefficients:\n                             Estimate Std. Error z value Pr(>|z|)    \n(Intercept)                  -0.30027    0.06527  -4.600 4.22e-06 ***\nrms::rcs(zage, 3)zage         0.40206    0.05099   7.885 3.16e-15 ***\nrms::rcs(zage, 3)zage'       -0.07337    0.05813  -1.262    0.207    \nrms::rcs(zincome, 3)zincome  -0.63792    0.04950 -12.888  < 2e-16 ***\nrms::rcs(zincome, 3)zincome' -0.04020    0.06434  -0.625    0.532    \nfactor(male)1                -0.25432    0.04415  -5.760 8.41e-09 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 13359  on 9999  degrees of freedom\nResidual deviance: 12193  on 9994  degrees of freedom\nAIC: 12205\n\nNumber of Fisher Scoring iterations: 4\n```\n\n\n:::\n:::\n\n\n\nThe model seems to indicate that the non-linear terms for age and income don't particularly matter (which [is expected](#treatmentpropensity)), but we'll leave it as-is. Next, let's attach the _estimated_ propensity scores to the `population`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation <-\n  population |>\n  \n  # Add the estimated propensity score\n  mutate(\n    pA_hat = predict(ps_mod, type = \"response\") # P(A = 1 | X)\n  )\n```\n:::\n\n\n\nWe can take a look at the estimated propensity score distribution across the treatment groups (we'll also overlay the _true_ distributions for comparison):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation |>\n  \n  # Send PS scores down the rows\n  pivot_longer(\n    cols = c(pA, pA_hat),\n    names_to = \"Type\",\n    values_to = \"Score\"\n  ) |>\n\n  # Clean labels\n  mutate(\n    Treatment = \n      case_when(\n        A == 1 ~ \"A\",\n        TRUE ~ \"B\"\n      ),\n    Type = \n      case_when(\n        Type == \"pA\" ~ \"True\",\n        TRUE ~ \"Estimated\"\n      )\n  ) |>\n  \n  # Make a plot\n  ggplot() + \n  geom_density(\n    aes(\n      x = Score,\n      fill = Treatment,\n      linetype = Type\n    ),\n    alpha = .40\n  ) +\n  scale_x_continuous(labels = scales::percent) +\n  theme(\n    panel.background = element_blank(),\n    axis.ticks.y = element_blank(),\n    axis.text.y = element_blank(),\n    axis.title.y = element_blank(),\n    legend.position = \"top\"\n  ) +\n  xlab(\"P(A=1|X)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\nThe model does a great job at estimating the true propensity scores. In a real analysis we probably wouldn't be this close since we likely wouldn't have only and all true confounders accounted for.\n\n### Visualizing propensity score effects\n\nIn the same vein, we can explore the modeled relationships between each patient characteristic and the propensity scores. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplots <-\n  population |>\n  \n  # Send PS scores down the rows\n  pivot_longer(\n    cols = c(pA, pA_hat),\n    names_to = \"Type\",\n    values_to = \"Score\"\n  ) |>\n  \n  # Clean labels\n  mutate(\n    Treatment = \n      case_when(\n        A == 1 ~ \"A\",\n        TRUE ~ \"B\"\n      ),\n    Type = \n      case_when(\n        Type == \"pA\" ~ \"True\",\n        TRUE ~ \"Estimated\"\n      )\n  ) |>\n  \n  # Send covariates down the rows\n  pivot_longer(\n    cols = c(zage, zincome, male),\n    names_prefix = \"^z\"\n  ) |>\n  \n  # Make groups\n  mutate(\n    Group = \n      case_when(\n        name == \"male\" ~ \"categorical\",\n        TRUE ~ \"continuous\"\n      )\n  ) |>\n  \n  # Make a nested frame\n  group_by(Group) |>\n  nest() |>\n  \n  # Make plot depending on type\n  mutate(\n    plot = \n      data |>\n      map(\n        function(.group) {\n          \n          # Check condition\n          if(n_distinct(.group$value) == 2) {\n            \n            .group |>\n              summarize(\n                Rate = mean(Score),\n                .by = c(Treatment, Type, name, value)\n              ) |>\n              mutate(\n                Sex = \n                  case_when(\n                    value == 1 ~ \"Male\",\n                    TRUE ~ \"Female\"\n                  ),\n                name = \"Sex\"\n              ) |>\n              ggplot() +\n              geom_point(\n                aes(\n                  x = Sex,\n                  y = Rate,\n                  color = Treatment,\n                  shape = Type,\n                  group = Type\n                )\n              ) +\n              geom_line(\n                aes(\n                  x = Sex,\n                  y = Rate,\n                  color = Treatment,\n                  linetype = Type,\n                  group = interaction(Type, Treatment)\n                )\n              ) +\n              facet_wrap(~name) +\n              coord_flip() +\n              scale_y_continuous(labels = scales::percent) +\n              theme(\n                panel.background = element_blank(),\n                panel.grid.major.x = element_line(color = \"gray\"),\n                legend.position = \"top\",\n                axis.title.y = element_blank()\n              ) +\n              ylab(\"P(A=1|X)\")\n            \n          } else {\n            \n            .group |> \n              ggplot() + \n              geom_smooth(\n                aes(\n                  x = value,\n                  y = Score,\n                  color = Treatment,\n                  fill = Treatment,\n                  linetype = Type\n                ),\n                alpha = .25\n              ) +\n              facet_wrap(~name) +\n              scale_y_continuous(labels = scales::percent) +\n              theme(\n                panel.background = element_blank(),\n                panel.grid.major.y = element_line(color = \"gray\"),\n                legend.position = \"top\"\n              ) +\n              xlab(\"Z-Score\") +\n              ylab(\"P(A=1|X)\")\n          }\n          \n        } \n      )\n  ) \n\ngridExtra::grid.arrange(plots$plot[[1]], plots$plot[[2]])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nAs known from the [true model](#treatmentpropensity), patients who received treatment _A_ tend to be older, female patients with lower income. We can also see slight miscalibration in the estimates for patients who are older in that the model tends to _underestimate_ the true propensity score in these patients. We see similar miscalibration for sex.\n\n## Calculate the (estimated) overlap weight {#estimatedoverlapweight}\n\nWe've already [defined](#trueoverlapweight) how to calculate the overlap weights. The only difference here is that we'll do it from the [_estimated_](#modelpropensityscores) propensity scores instead of the [true](#treatmentpropensity) ones. First, we'll apply the formula to add the estimated weights to the `population`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation <-\n  population |>\n  \n  # Add the estimated overlap weight for the realized treatment (known quantity)\n  mutate(\n    OW_hat = A * (1-pA_hat) + (1-A) * pA_hat\n  )\n```\n:::\n\n\n\nAs we've [mentioned earlier](#targetpopulation), we will then _normalize_ the weights _within_ each treatment group so they have the same cumulative contribution for estimating the treatment effect in the outcome model.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation <- \n  population |>\n  \n  # Add the normalized weights (adding true and estimated)\n  mutate(\n    OW_norm = OW / sum(OW),\n    OW_hat_norm = OW_hat / sum(OW_hat),\n    .by = A\n  )\npopulation |> select(A, pA, pA_hat, OW, OW_norm, OW_hat, OW_hat_norm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,000 × 7\n       A    pA pA_hat    OW   OW_norm OW_hat OW_hat_norm\n   <int> <dbl>  <dbl> <dbl>     <dbl>  <dbl>       <dbl>\n 1     1 0.577  0.583 0.423 0.000202   0.417   0.000198 \n 2     0 0.422  0.427 0.422 0.000201   0.427   0.000202 \n 3     1 0.647  0.610 0.353 0.000168   0.390   0.000185 \n 4     0 0.219  0.226 0.219 0.000105   0.226   0.000107 \n 5     1 0.315  0.329 0.685 0.000327   0.671   0.000318 \n 6     1 0.292  0.265 0.708 0.000338   0.735   0.000348 \n 7     0 0.644  0.628 0.644 0.000307   0.628   0.000297 \n 8     0 0.171  0.181 0.171 0.0000814  0.181   0.0000856\n 9     0 0.238  0.250 0.238 0.000114   0.250   0.000118 \n10     0 0.257  0.268 0.257 0.000123   0.268   0.000127 \n# ℹ 9,990 more rows\n```\n\n\n:::\n:::\n\n\n\nTo get a sense of the impact of these weights, let's first look at their distributions (again, adding the [true](#trueoverlapweight) weights for comparison):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation |>\n  \n  # Send overlap weight down the rows\n  pivot_longer(\n    cols = c(OW_norm, OW_hat_norm),\n    names_to = \"Type\",\n    values_to = \"Weight\"\n  ) |>\n  \n  # Clean labels\n  mutate(\n    Treatment = \n      case_when(\n        A == 1 ~ \"A\",\n        TRUE ~ \"B\"\n      ),\n    Type = \n      case_when(\n        Type == \"OW_norm\" ~ \"True\",\n        TRUE ~ \"Estimated\"\n      )\n  ) |>\n  \n  # Make a plot\n  ggplot() + \n  geom_density(\n    aes(\n      x = Weight,\n      fill = Treatment,\n      linetype = Type\n    ),\n    alpha = .40\n  ) +\n  theme(\n    panel.background = element_blank(),\n    axis.ticks.y = element_blank(),\n    axis.text.y = element_blank(),\n    axis.title.y = element_blank(),\n    legend.position = \"top\"\n  ) +\n  xlab(\"Normalized Overlap Weight\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\nIn aggregate, the groups will have equal weight. The distribution shift has to do with the sampled treatment distribution. Only 38.8% of patients have treatment _A_ so at an individual level each patient will contribute more on average.\n\n### Cumulative patient contribution\n\nWe can also look at the accumulation of _patients_ (i.e., when each patient contributes equally) as a function of the cumulative _overlap weight_ in each group. This allows us to understand how much (or little) the treatment effect estimation will be dominated by smaller concentrations of patients.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation |>\n  \n  # Send overlap weight down the rows\n  pivot_longer(\n    cols = c(OW_norm, OW_hat_norm),\n    names_to = \"Type\",\n    values_to = \"Weight\"\n  ) |>\n  \n  # Clean labels\n  mutate(\n    Treatment = \n      case_when(\n        A == 1 ~ \"A\",\n        TRUE ~ \"B\"\n      ),\n    Type = \n      case_when(\n        Type == \"OW_norm\" ~ \"True\",\n        TRUE ~ \"Estimated\"\n      ),\n    NullWeight = 1\n  ) |> \n  \n  # Rearrange\n  arrange(Treatment, Type, Weight) |>\n  \n  # Compute the cumulative weight\n  mutate(\n    Weight = cumsum(Weight) / sum(Weight),\n    NullWeight = cumsum(NullWeight) / sum(NullWeight),\n    .by = c(Treatment, Type)\n  ) |> \n  \n  # Make a plot\n  ggplot() + \n  geom_line(\n    aes(\n      x = Weight,\n      y = NullWeight,\n      color = Treatment,\n      linetype = Type\n    ),\n    linewidth = 1\n  ) +\n  scale_x_continuous(labels = scales::percent) +\n  scale_y_continuous(labels = scales::percent) +\n  theme(\n    panel.background = element_blank(),\n    panel.grid.major.x = element_line(color = \"gray\"),\n    panel.grid.major.y = element_line(color = \"gray\"),\n    legend.position = \"top\"\n  ) +\n  xlab(\"Cumulative percent of overlap weight (%)\") +\n  ylab(\"Cumulative percent of patients (%)\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\nWe can see that for treatment _B_, about 40% of the outcome model weight will be accounted for by only 25% of patients. The weights for treatment _A_ are slightly more evenly spread across the patients.\n\n### Weighted-mean differences\n\nIt was [previously mentioned](#treatmentpropensity) that the overlap weight methodology leads to perfect balance among the covariates used in the propensity score model. We can verify by looking at the group means for [each model factor](#modelpropensityscores) before and after weighting.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation |> \n  \n  # Add uniform weights\n  add_column(NullWeight = 1) |>\n  \n  # Send weights down the rows\n  pivot_longer(\n    cols = c(NullWeight, OW_hat_norm),\n    names_to = \"Type\",\n    values_to = \"Weight\"\n  ) |> \n  \n  # Send factors down the rows\n  pivot_longer(\n    cols = c(age, income, male),\n    names_to = \"Factor\",\n    values_to = \"Value\"\n  ) |> \n  \n  # For each \n  summarize(\n    Patients = n(),\n    Mean = sum(Weight * Value) / sum(Weight),\n    .by = c(Factor, Type, A)\n  ) |>\n  \n  # Clean up\n  transmute(\n    Factor = \n      case_when(\n        Factor == \"age\" ~ \"Age (years)\",\n        Factor == \"income\" ~ \"Income ($)\",\n        Factor == \"male\" ~ \"Male (%)\"\n      ),\n    Treatment = \n      case_when(\n        A == 1 ~ \"A\",\n        TRUE ~ \"B\"\n      ),\n    Type,\n    Patients,\n    Mean = \n      case_when(\n        Factor == \"Male (%)\" ~ 100 * Mean,\n        TRUE ~ Mean\n      )\n  ) |>\n  \n  # Send over the columns\n  pivot_wider(\n    names_from = Type,\n    values_from = c(Patients, Mean)\n  ) |> \n  \n  # Rearrange\n  arrange(Factor, Treatment) |>\n  select(Factor, Treatment, ends_with(\"NullWeight\"), Mean_OW_hat_norm) |> \n  \n  # Make a table\n  reactable(\n    groupBy = \"Factor\",\n    columns = \n      list(\n        Patients_NullWeight = colDef(name = \"Patients\", aggregate = \"sum\", align = \"center\"),\n        Mean_NullWeight = colDef(name = \"Before Weighting\", aggregate = zildge::rectbl_agg_wtd(\"Patients_NullWeight\"), align = \"center\", format = colFormat(digits = 1)),\n        Mean_OW_hat_norm = colDef(name = \"After Weighting\", aggregate = zildge::rectbl_agg_wtd(\"Patients_NullWeight\"), align = \"center\", format = colFormat(digits = 1))\n      ),\n    columnGroups = \n      list(\n        colGroup(\n          name = \"Mean Value\",\n          columns = c(\"Mean_NullWeight\", \"Mean_OW_hat_norm\")\n        )\n      ),\n    striped = TRUE,\n    highlight = TRUE,\n    bordered = TRUE,\n    resizable = TRUE,\n    theme = reactablefmtr::sandstone()\n  ) |>\n  reactablefmtr::add_source(\"Use arrows to expand table\", font_size = 12, font_style = \"italic\")\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"reactable html-widget html-fill-item\" id=\"htmlwidget-858fd2eb03b0c0ded5eb\" style=\"width:auto;height:auto;\"></div>\n<p style=\"color:#000;background:#FFFFFF;text-align:left;font-size:12px;font-style:italic;font-weight:normal;text-decoration:;letter-spacing:px;word-spacing:px;text-transform:;text-shadow:;margin-top:0px;margin-right:0px;margin-bottom:0px;margin-left:0px\">Use arrows to expand table</p>\n<script type=\"application/json\" data-for=\"htmlwidget-858fd2eb03b0c0ded5eb\">{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"Factor\":[\"Age (years)\",\"Age (years)\",\"Income ($)\",\"Income ($)\",\"Male (%)\",\"Male (%)\"],\"Treatment\":[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"],\"Patients_NullWeight\":[3882,6118,3882,6118,3882,6118],\"Mean_NullWeight\":[51.8724351584411,48.7731344443606,46.152542137955,52.1470439747779,55.7444616177228,61.7522066034652],\"Mean_OW_hat_norm\":[50.6909470423481,50.6909470423472,48.480546358988,48.4805463589892,58.1435359891369,58.1435359891387]},\"columns\":[{\"id\":\"Factor\",\"name\":\"Factor\",\"type\":\"character\"},{\"id\":\"Treatment\",\"name\":\"Treatment\",\"type\":\"character\"},{\"id\":\"Patients_NullWeight\",\"name\":\"Patients\",\"type\":\"numeric\",\"aggregate\":\"sum\",\"align\":\"center\"},{\"id\":\"Mean_NullWeight\",\"name\":\"Before Weighting\",\"type\":\"numeric\",\"aggregate\":\"function(values, rows) {\\n            var numerator = 0\\n            var denominator = 0\\n\\n            rows.forEach(function(row, index) {\\n                numerator += row['Patients_NullWeight'] * values[index]\\n                denominator += row['Patients_NullWeight']\\n            })\\n\\n            if('mean' == 'mean') {\\n                return numerator / denominator\\n            } else {\\n                return numerator\\n            }\\n        }\",\"format\":{\"cell\":{\"digits\":1},\"aggregated\":{\"digits\":1}},\"align\":\"center\"},{\"id\":\"Mean_OW_hat_norm\",\"name\":\"After Weighting\",\"type\":\"numeric\",\"aggregate\":\"function(values, rows) {\\n            var numerator = 0\\n            var denominator = 0\\n\\n            rows.forEach(function(row, index) {\\n                numerator += row['Patients_NullWeight'] * values[index]\\n                denominator += row['Patients_NullWeight']\\n            })\\n\\n            if('mean' == 'mean') {\\n                return numerator / denominator\\n            } else {\\n                return numerator\\n            }\\n        }\",\"format\":{\"cell\":{\"digits\":1},\"aggregated\":{\"digits\":1}},\"align\":\"center\"}],\"columnGroups\":[{\"name\":\"Mean Value\",\"columns\":[\"Mean_NullWeight\",\"Mean_OW_hat_norm\"]}],\"groupBy\":[\"Factor\"],\"resizable\":true,\"highlight\":true,\"bordered\":true,\"striped\":true,\"theme\":{\"color\":\"#3e3f3a\",\"backgroundColor\":\"#ffffff\",\"borderColor\":\"#f8f5f0\",\"borderWidth\":\"1px\",\"stripedColor\":\"#ededed\",\"highlightColor\":\"#f8f5f0\",\"cellPadding\":6,\"tableStyle\":{\"fontSize\":15},\"headerStyle\":{\"borderWidth\":\"2px\",\"backgroundColor\":\"#f8f5f0\",\"color\":\"#7c7a78\",\"transitionDuration\":\"0.5s\",\"&:hover[aria-sort]\":{\"color\":\"#000000\"},\"&[aria-sort='ascending'], &[aria-sort='descending']\":{\"color\":\"#000000\"},\"fontSize\":16},\"groupHeaderStyle\":{\"&:not(:empty)\":{\"color\":\"#3e3f3a\",\"fontSize\":16},\"&:hover\":{\"fontWeight\":\"bold\",\"transitionDuration\":\"1s\",\"transitionTimingFunction\":\"ease-out\",\"color\":\"#000000\"}},\"rowSelectedStyle\":{\"backgroundColor\":\"#dfd7ca\",\"color\":\"#8e8c84\"},\"inputStyle\":{\"backgroundColor\":\"#ffffff\",\"borderColor\":\"#bcbfc1\",\"color\":\"#3e3f3a\"},\"searchInputStyle\":{\"backgroundColor\":\"#ffffff\",\"color\":\"#3e3f3a\",\"borderColor\":\"#bcbfc1\",\"&:focus\":{\"color\":\"#3e3f3a\"}},\"selectStyle\":{\"backgroundColor\":\"#dfd7ca\",\"color\":\"#8e8c84\",\"borderColor\":\"#ffffff\",\"outlineColor\":\"#ffffff\"},\"pageButtonStyle\":{\"backgroundColor\":\"#f8f5f0\",\"color\":\"#8e8c84\",\"&:hover\":{\"backgroundColor\":\"#f3969a\",\"color\":\"#8e8c84\"}},\"pageButtonHoverStyle\":{\"backgroundColor\":\"#dfd7ca\",\"color\":\"#8e8c84\"},\"pageButtonActiveStyle\":{\"backgroundColor\":\"#dfd7ca\",\"color\":\"#8e8c84\"},\"pageButtonCurrentStyle\":{\"backgroundColor\":\"#dfd7ca\",\"color\":\"#8e8c84\"}},\"dataKey\":\"0e103bb7f71d932df5c23f1aa11d9ef7\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[\"tag.attribs.columns.3.aggregate\",\"tag.attribs.columns.4.aggregate\"],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\nWe can see that, overall, the weighted sample is _slightly_ older and female with lower income.\n\n### Confounder weight shifts\n\nSimilar to looking at weight attributions [as a whole](#estimatedoverlapweight), we can explore weight shifts within subgroups of patient characteristics. This helps build intuition about which patients the subsequent treatment effect estimates will focus on most (and least). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation |> \n  \n  # Add uniform weights\n  add_column(NullWeight = 1) |>\n  \n  # Convert to quntiles\n  mutate(\n    across(\n      c(age, income),\n      \\(x) Hmisc::cut2(x, g = 10)\n    ),\n    Age = age,\n    Income = income,\n    Sex = \n      case_when(\n        male == 1 ~ \"Male\",\n        TRUE ~ \"Female\"\n      ),\n    Treatment = \n      case_when(\n        A == 1 ~ \"A\",\n        TRUE ~ \"B\"\n      )\n  ) |> \n  \n  # Send weights down the rows\n  pivot_longer(\n    cols = c(NullWeight, OW_hat_norm),\n    names_to = \"Type\",\n    values_to = \"Weight\"\n  ) |>\n  \n  # Send factors down the rows\n  pivot_longer(\n    cols = c(Age, Income, Sex),\n    names_to = \"Factor\",\n    values_to = \"Level\"\n  ) |> \n  \n  # Compute total weights\n  summarize(\n    Weight = sum(Weight),\n    .by = c(Factor, Level, Type, Treatment)\n  ) |>\n  \n  # Find percent of weight\n  mutate(\n    Weight = Weight / sum(Weight),\n    .by = c(Factor, Type, Treatment)\n  ) |>\n  \n  # Send over columns\n  pivot_wider(\n    names_from = Type,\n    values_from = Weight\n  ) |>\n  \n  # Clean up\n  mutate(\n    Level = factor(Level) |> fct_rev(),\n    Factor = \n      case_when(\n        Factor == \"Age\" ~ \"Age (years)\",\n        Factor == \"Income\" ~ \"Income ($)\",\n        TRUE ~ Factor\n      )\n  ) |>\n  \n  # Make a plot\n  ggplot() +\n  geom_col(\n    aes(\n      x = Level,\n      y = NullWeight,\n      fill = Treatment\n    ),\n    color = \"black\",\n    linewidth = .75,\n    alpha = .40,\n    position = \"dodge\"\n  ) + \n  geom_point(\n    aes(\n      x = Level,\n      y = OW_hat_norm,\n      color = Treatment,\n      shape = Treatment\n    ),\n    position = position_dodge(width = 1),\n    size = 3\n  ) +\n  geom_line(\n    aes(\n      x = Level,\n      y = OW_hat_norm,\n      color = Treatment,\n      group = Treatment\n    ),\n    position = position_dodge(width = 1),\n    linewidth = .5\n  ) +\n  facet_wrap(~Factor, scales = \"free\") +\n  coord_flip() +\n  scale_y_continuous(labels = scales::percent) +\n  theme(\n    panel.background = element_blank(),\n    panel.grid.major.x = element_line(color = \"gray\"),\n    legend.position = \"top\"\n  ) +\n  xlab(\"Level\") +\n  ylab(\"Share of weight within group (%)\") +\n  labs(\n    fill = \"Before Weighting\",\n    shape = \"After Weighting\",\n    color = \"After Weighting\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\nWe can see the balancing take place. After overlap weighting, the contribution to treatment effect estimation is reduced in older patients with lower income for treatment _A_, and vice-versa for treatment _B_, with some levels in the middle having increased weight for _both_ treatments. This is where the most overlap is between the groups.\n\nIt is also useful to look at these plots for factors that were _not_ included in the propensity score model. We may find drastic weight shifts which might indicate significant co-variation among factors already accounted for.\n\n# Estimating the treatment effect {#estimatingtreatmenteffect}\n\nWe're now ready to estimate the causal treatment effect. Although we [generated our data](#treatmenteffect) from a [Weibull](https://en.wikipedia.org/wiki/Weibull_distribution) distribution, we will use a [Cox proportional-hazards model](https://en.wikipedia.org/wiki/Proportional_hazards_model) for estimation, which is a _semi-parametric_ method, and tends to be the default choice for modeling survival data, especially in healthcare. \n\n## A look at the true hazard ratio {#truehazardratio}\n\nThe treatment effect will be quantified by a [_hazard ratio_](https://en.wikipedia.org/wiki/Hazard_ratio), which is an estimate of the ratio of instantaneous event rates between the treatment groups (this is what is done in [the original simulation](https://www2.stat.duke.edu/~fl35/OW/OW_survival_Demo.sas)). This measure is different than the effect we [interpreted](#interpretingtreatmenteffect) from the true data-generating process, so, although we won't expect them to provide the same numerical result, we should still get a similar conclusion, in that treatment _A_ is superior to treatment _B_.\n\nTo start, we can compute the actual hazard ratio had we been able to observe each potential outcome (i.e., the counterfactual). To do this, we need to transform our data such that we have two rows of data per patient--one for each treatment. Then, we fit the Cox model, using the _true_ overlap weights as case weights.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit the model\ntrue_hr_mod <-\n  coxph(\n    formula = Surv(time, status) ~ factor(A),\n    data = \n      population |>\n      \n      # Keep columns needed\n      select(\n        OW_norm, # True (normalized) overlap weight (could use un-normalized version here)\n        t_A, # True event time under treatment A\n        t_B, # True event time under treatment B\n        censor_time # When the patient was censored\n      ) |>\n      \n      # Send true event times down the rows\n      pivot_longer(\n        cols = c(t_A, t_B),\n        names_to = \"A\",\n        values_to = \"time\"\n      ) |>\n      \n      # Check if censored first\n      mutate(\n        A = case_when(A == \"t_A\" ~ 1, TRUE ~ 0), # Replace with our notation\n        time = pmin(time, censor_time),\n        status = as.numeric(time < censor_time)\n      ),\n    weights = OW_norm\n  )\n\n# Extract the result\ntrue_hr <- exp(true_hr_mod$coefficients)[[1]]\ntrue_hr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7284168\n```\n\n\n:::\n:::\n\n\n\nIf we could compare the worlds in which we observe all patients under each treatment, the hazard ratio is 0.73, suggesting that the instantaneous event rate is 27% lower with treatment _A_ than with treatment _B_. This aligns with what we've established as the [true effect](#interpretingtreatmenteffect). Our hope is that the estimate from the observable data (in the [next section](#estimatedhazardratio)) will contain this value within some margin of sampling error.\n\n## Our estimate of the treatment effect {#estimatedhazardratio}\n\nFinally, we can obtain our estimate of the treatment effect using only the observable quantities we have in our data set, which is what we would have in a real-life analysis. Similar to the [previous section](##truehazardratio), we are just fitting a Cox model with the treatment as a covariate. Except this time we only observe one outcome per patient as a result of the treatment they [actually received](#treatmentassignment), and use the [_estimated_ overlap weight](#estimatedoverlapweight) to balance the confounding factors (age, sex, and income). We will also use [robust](https://rdrr.io/cran/survival/man/coxph.html) standard error estimates.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit the model\nestimated_hr_mod <-\n  coxph(\n    formula = Surv(time, status) ~ factor(A),\n    data = population,\n    weights = OW_hat_norm,\n    robust = TRUE\n  )\n\n# Extract the result\nestimated_hr <- exp(estimated_hr_mod$coefficients)[[1]]\nestimated_hr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7423806\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract the confidence interval\nestimated_hr_ci <- exp(confint(estimated_hr_mod))\nestimated_hr_ci\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               2.5 %    97.5 %\nfactor(A)1 0.6756889 0.8156548\n```\n\n\n:::\n:::\n\n\n\nOur estimate for the hazard ratio is 0.74, with a 95% confidence interval ranging from 0.68 to 0.82, suggesting that the instantaneous event rate for treatment _A_ is between 18% and 32% lower compared to treatment _B_ (note that this captures the [true hazard ratio](#truehazardratio)). Under the assumption that we've correctly specified all confounding factors (which [we did](#treatmentpropensity)), we can interpret this as the _causal_ treatment effect, and, assuming the magnitude of improvement is of practical importance (when considering things like cost, resources, clinical outcomes, etc.), we can reliably conclude that there is a benefit to treatment _A_ over treatment _B_, on average.\n\n# Resources {#resources}\n\nSome additional resources I've come across while learning the methodology:\n\n* Original paper for overlap weighting ([link](https://pubmed.ncbi.nlm.nih.gov/30189042/))\n* Paper extending overlap weighting to survival analysis ([link](https://arxiv.org/abs/2108.04394))\n* Example simulation of overlap weighting in the survival setting in SAS ([link](http://www2.stat.duke.edu/~fl35/OW/OW_survival_Demo.sas))\n* R package for implementing overlap weight methods ([link](https://github.com/thuizhou/PSweight))\n* R functions for overlap weighting in the survival setting ([link](https://github.com/chaochengstat/OW_Survival))\n* Author's web page dedicated to overlap weighting ([link](https://www2.stat.duke.edu/~fl35/OW.html))",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/core-js-2.5.3/shim.min.js\"></script>\n<script src=\"../../site_libs/react-18.2.0/react.min.js\"></script>\n<script src=\"../../site_libs/react-18.2.0/react-dom.min.js\"></script>\n<script src=\"../../site_libs/reactwidget-2.0.0/react-tools.umd.cjs\"></script>\n<link href=\"../../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/reactable-0.4.4/reactable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/reactable-binding-0.4.4/reactable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}