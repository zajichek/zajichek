{
  "hash": "cb929f6e20ba7a75c8215c9e91e05366",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The Evasive Spline\"\ndescription: \"Basis Functions & Splines\"\nauthor: \"Alex Zajichek\"\ndate: \"1/13/2023\"\nimage: \"feature.png\"\ncategories:\n  - Estimation\n  - Modeling\nformat:\n  html:\n    code-fold: true\n    code-tools: true\n---\n\n\n\nThis one always gets me. I've learned and forgot how splines work many times over the years, and when I need to relearn it, I read the _Moving Beyond Linearity_ chapter of [An Introduction to Statistical Learning](https://www.statlearning.com/). \n\n**Basis Functions** are just a general approach for transforming a simple model like:\n\n$$Y_i = \\beta_0 + \\beta_1X_i + \\epsilon_i$$\ninto a linear combination of transformations of the $X_i$ of the form:\n\n$$Y_i = \\beta_0 + \\beta_1b_1(X_i) + \\beta_2b_2(X_i) + ... + \\beta_Kb_k(X_i) + \\epsilon_i$$\nwhere $b_i$ is a known function that transforms the predictor variable. _Note: $\\beta_1$ is not the same in both of these, they are just placeholders for an arbitrary parameter._ For example, in the case of a piecewise regression where the model is of the form:\n\n$$Y_i = \\beta_0 + \\beta_1I(X_i < c_1) + \\beta_2I(c_1 < X_i < c_2) + ... + \\beta_kI(c_{k-1} < X_i < c_k) + \\epsilon_i$$\nthe indicators are _basis functions_ such that:\n\n$$b_j(X_i) = I(c_{j-1} < X_i < c_j) \\hskip.1in \\text{for j=1,..,k}$$\nor in a polynomial model, the basis functions are $b_j(X_i) = X_i^j$.\n\n**Knots** are points (cutoffs) along $X_i$ that a _local_ regression starts/ends. For example, we might fit a cubic model (e.g., with parameters $\\beta_1, \\beta_2, \\beta_3$) where $X_i < C$, and another model (with a _separate_ set of $\\beta_1, \\beta_2, \\beta_3$) where $X_i \\geq C$. $C$ is a _knot_. In this sense, the piecewise regression above was also a polynomial regression with degree 0, and knots at each value of $c_j$.\n\nThe general problem with an unconstrained polynomial model is that there are no restrictions that force a smooth function across $X$, so there are discontinuities. Thus, restrictions need to be put in place such as (1) making it continuous at the knot(s), and/or even further, (2) making the first and second derivatives continuous at the knots. These restrictions reduce the complexity of the model (i.e., the number of parameters we estimate). \n\n# Cubic Splines\n\nA cubic spline with $K$ knots uses $K+4$ parameters. The best way to do this is to use (1) the basis of a cubic polynomial ($x, x^2, x^3$) and (2) a truncated power basis _for each knot_:\n\n$$h(x,\\nu) = {(x-\\nu)}_+^3$$\nwhere $\\nu$ is the knot location. Thus, a _one-knot_ model looks like:\n\n$$Y_i = \\beta_0 + \\beta_1X_i + \\beta_2X_i^2 + \\beta_3X_i^3 + \\beta_4h(X_i,\\nu_1) + \\epsilon_i$$\nWe can add more knots as needed, and it simply adds $h(x,\\nu)$ terms only (so 1 more parameter per knot). A function of this form is guaranteed to have continuous first and second derivatives.\n\n**So how does this relate to what is produced in the `rcs` function from the `rms` package?**\n\nWell, the package actually fits a _restricted_ cubic spline, which is a _natural spline_. This adds even more restrictions that the general cubic spline by forcing it to be _linear_ where $X$ is less than the smallest knot and where $X$ is larger than the largest not (i.e., the boundaries). These add an additional _two_ constraints at _each_ boundary. So if we have a regular cubic spline model above with 3 knots (i.e., 7 parameters), then a _restricted_ cubic spline model with 3 knots should have only 3 parameters.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nx <- rnorm(100)\ny <- .5*x^2 - .75*x + rnorm(100)\nx_trans <- rms::rcs(x, 3)\nhead(x_trans)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               x         x'\n[1,] -0.56047565 0.02405534\n[2,] -0.23017749 0.10816181\n[3,]  1.55870831 2.14013743\n[4,]  0.07050839 0.27135366\n[5,]  0.12928774 0.31547103\n[6,]  1.71506499 2.36735648\nattr(,\"class\")\n[1] \"rms\"\nattr(,\"name\")\n[1] \"x\"\nattr(,\"label\")\n[1] \"x\"\nattr(,\"assume\")\n[1] \"rcspline\"\nattr(,\"assume.code\")\n[1] 4\nattr(,\"parms\")\n[1] -1.06822046  0.06175631  1.26449867\nattr(,\"nonlinear\")\n[1] FALSE  TRUE\nattr(,\"colnames\")\n[1] \"x\"  \"x'\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(lm(y~x_trans))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x_trans)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1.9888 -0.7341 -0.0803  0.6900  3.2215 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  -0.3838     0.1842  -2.084   0.0398 *  \nx_transx     -1.6552     0.2449  -6.758 1.04e-09 ***\nx_transx'     1.2922     0.2925   4.417 2.61e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.9823 on 97 degrees of freedom\nMultiple R-squared:  0.3805,\tAdjusted R-squared:  0.3677 \nF-statistic: 29.79 on 2 and 97 DF,  p-value: 8.214e-11\n```\n\n\n:::\n:::\n\n\n\nWe can see this model contains three estimated parameters as expected. The actual transformation completed for the restricted cubic spline in producing, in general, the $K-2$ additional predictors is more complex than the cubic spline (although similar). In this case, the 3 knot positions were selected to be:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknots <- attr(x_trans, \"parms\")\nknots\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.06822046  0.06175631  1.26449867\n```\n\n\n:::\n:::\n\n\n\nNote, these are just the $10^{th}, 50^{th}, 90^{th}$ percentiles:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile(x, c(.1,.5,.9))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        10%         50%         90% \n-1.06822046  0.06175631  1.26449867 \n```\n\n\n:::\n:::\n\n\n\nThe following transformation is made (general solution [here](https://support.sas.com/resources/papers/proceedings16/5621-2016.pdf)):\n\n$$X_{trans} = (x-\\nu_1)_+^3 - (x-\\nu_2)_+^3\\frac{\\nu_3-\\nu_1}{\\nu_3-\\nu_2} + (x-\\nu_3)_+^3\\frac{\\nu_2-\\nu_1}{\\nu_3-\\nu_2}$$\nLet's check out that transformation on our data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble::tibble(\n  x = as.numeric(x_trans[,\"x\"]),\n  x_trans_actual = as.numeric(x_trans[,\"x'\"]),\n  x_trans_calculated = \n    pmax((x-knots[1])^3, 0) -\n    pmax((x-knots[2])^3, 0) * ((knots[3]-knots[1]) / (knots[3]-knots[2])) +\n    pmax((x-knots[3])^3, 0) * ((knots[2]-knots[1])/(knots[3]-knots[2]))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 3\n         x x_trans_actual x_trans_calculated\n     <dbl>          <dbl>              <dbl>\n 1 -0.560          0.0241             0.131 \n 2 -0.230          0.108              0.589 \n 3  1.56           2.14              11.6   \n 4  0.0705         0.271              1.48  \n 5  0.129          0.315              1.72  \n 6  1.72           2.37              12.9   \n 7  0.461          0.634              3.45  \n 8 -1.27           0                  0     \n 9 -0.687          0.0102             0.0555\n10 -0.446          0.0443             0.241 \n# ℹ 90 more rows\n```\n\n\n:::\n:::\n\n\n\nFor some reason this is close but off by a factor close to 5? Looking into the documentation/code, it is because of the `norm` argument in the `Hmisc::rcspline.eval` function. When we run this, we get the same result that we calculated (which is the original restricted cubic spline calculation):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(Hmisc::rcspline.eval(x,nk=3, norm = 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]\n[1,]  0.130899\n[2,]  0.588571\n[3,] 11.645726\n[4,]  1.476592\n[5,]  1.716660\n[6,] 12.882156\n```\n\n\n:::\n:::\n\n\n\nBy default, this function uses `norm=2`, which _\"normalizes by the square of the spacing between the first and last knots...has the advantage of making all nonlinear terms be on the x-scale\"_.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(Hmisc::rcspline.eval(x,nk=3, norm = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]\n[1,] 0.02405534\n[2,] 0.10816181\n[3,] 2.14013743\n[4,] 0.27135366\n[5,] 0.31547103\n[6,] 2.36735648\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}